(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{369:function(t,s,a){"use strict";a.r(s);var n=a(45),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"es6"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es6"}},[t._v("#")]),t._v(" ES6")]),t._v(" "),a("h2",{attrs:{id:"_1-let、const和var的概念与区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-let、const和var的概念与区别"}},[t._v("#")]),t._v(" 1. let、const和var的概念与区别")]),t._v(" "),a("p",[t._v("let、const 是 ES6 新增的两个声明变量的命令，用法类似于于 var。\nvar 声明的变量会提升到当前作用域的最顶端，注意只提升声明，不提升赋值。")]),t._v(" "),a("p",[t._v("let 不存在变量提升")]),t._v(" "),a("p",[t._v("只要是 let 声明的变量会“绑定”到当前作用域，不会受外部影响，在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”，总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。")]),t._v(" "),a("p",[t._v("let 不允许同一作用域内重复声明同一个变量，var可以重复声明。")]),t._v(" "),a("p",[t._v("因此，函数内部不能使用let重复声明参数")]),t._v(" "),a("p",[t._v("var、function属于全局变量，是顶层对象的属性，let、const、class 不属于顶层对象属性，不可通过window.去访问")]),t._v(" "),a("p",[t._v("const 声明一个只读的常量，一旦被声明就不允许改变。")]),t._v(" "),a("p",[t._v("const和let一样声明只在块级作用域有效，同样没有变量提升，和存在暂时性死区，也不可重复声明")]),t._v(" "),a("p",[t._v("我们都知道，基本类型数据存在栈内存中，引用类型数据只是在栈内存存储了一个指向堆内存的指针，实际数据存放在堆内存中。 const并不是保证这个变量不可以改变，而是保证这个变量指向的占内存的值不可改变，所以使用const创建引用类型数据要小心")]),t._v(" "),a("h2",{attrs:{id:"_2-变量提升与暂时性死区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-变量提升与暂时性死区"}},[t._v("#")]),t._v(" 2. 变量提升与暂时性死区")]),t._v(" "),a("p",[a("strong",[t._v("var 存在变量提升， let 和 const 不存在变量提升")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" name"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'jack'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  name"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'bob'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//Uncaught ReferenceError: Cannot access 'name' before initialization")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("记住 ES6 中的一个特性，如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。因为JS清楚地感知到了 name 是用 let 声明在当前这个代码块内的，所以会给这个变量 name 加上了暂时性死区的限制，它就不往外探出头了。")]),t._v(" "),a("h2",{attrs:{id:"_3-变量的结构赋值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-变量的结构赋值"}},[t._v("#")]),t._v(" 3. 变量的结构赋值")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/6873482248625225741",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考链接"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"_4-箭头函数及其this问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-箭头函数及其this问题"}},[t._v("#")]),t._v(" 4. 箭头函数及其this问题")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//1.2一个参数（括号可以省略）")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("f")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("v")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 等同于")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("f")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("v")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("f")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 等同于")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("f")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("sum")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("num1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" num2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" num1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" num2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 等同于")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("sum")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("num1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" num2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" num1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" num2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Person")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'lihh'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("age "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("18")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setInterval")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'我叫'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'今年'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("age"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n打印结果是"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),t._v("指向了Person\n")])])]),a("p",[t._v("箭头函数使得表达更加简洁。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("isEven")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("n")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" n "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("square")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("n")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" n "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),a("ul",[a("li",[t._v("箭头函数没有自己的this，他是在定义函数的时候绑定的，而不是在执行过程中绑定的，它继承了定义函数的对象")]),t._v(" "),a("li",[t._v("箭头函数的一个用处是简化回调函数。")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 正常函数写法")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("map")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("x")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 箭头函数写法")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("map")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("x")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。\nthis指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。")]),t._v(" "),a("h2",{attrs:{id:"_5-symbol概念及其作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-symbol概念及其作用"}},[t._v("#")]),t._v(" 5. Symbol概念及其作用")]),t._v(" "),a("p",[t._v("ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。")]),t._v(" "),a("p",[t._v("ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。")]),t._v(" "),a("p",[t._v("Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("Symbol 的引入是为了防止对象属性名冲突")])]),t._v(" "),a("li",[a("p",[t._v("Symbol 是一种新的原始数据类型")])]),t._v(" "),a("li",[a("p",[t._v("Symbol 值是独一无二的")])]),t._v(" "),a("li",[a("p",[t._v("symbols 作为对象的属性 symbols 有另一个很重要的用途，就是用作对象的 key。这儿有一个 symbols 作为对象 key 使用的例子：")])])]),t._v(" "),a("ol",[a("li",[t._v("添加描述属性")])]),t._v(" "),a("p",[t._v("const sym = Symbol('foo');")]),t._v(" "),a("p",[t._v('sym.description // "foo"')]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("作为属性名的 Symbol")])]),t._v(" "),a("p",[t._v("由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。")]),t._v(" "),a("p",[t._v("let mySymbol = Symbol();")]),t._v(" "),a("p",[t._v("let a = {};")]),t._v(" "),a("p",[t._v("a[mySymbol] = 'Hello!';")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("共享Symbol")])]),t._v(" "),a("p",[t._v("有时，我们希望重新使用同一个 Symbol 值，Symbol.for()方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。")]),t._v(" "),a("p",[t._v("let s1 = Symbol.for('foo');")]),t._v(" "),a("p",[t._v("let s2 = Symbol.for('foo');")]),t._v(" "),a("p",[t._v("s1 === s2 // true")]),t._v(" "),a("p",[t._v("上面代码中，s1和s2都是 Symbol 值，但是它们都是由同样参数的Symbol.for方法生成的，所以实际上是同一个值。")]),t._v(" "),a("p",[t._v('Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for("cat")30 次，每次都会返回同一个 Symbol 值，但是调用Symbol("cat")30 次，会返回 30 个不同的 Symbol 值。')]),t._v(" "),a("h2",{attrs:{id:"_6-set和map数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-set和map数据结构"}},[t._v("#")]),t._v(" 6. Set和Map数据结构")]),t._v(" "),a("h3",{attrs:{id:"map"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[t._v("#")]),t._v(" MAP")]),t._v(" "),a("p",[t._v("作用：Map对象用于保存键值对，它的键可以为任意类型的数据，常用于建立数据的映射关系。")]),t._v(" "),a("p",[t._v("Map 中的 key    key是字符串")]),t._v(" "),a("p",[t._v("用法： Map()是一个构造函数，需要用new来实例化，Map()构造函数貌似只能接收一个二维数组的参数null和undefined（至少目前遇到的是这样），其他类型参数会报错")]),t._v(" "),a("ol",[a("li",[t._v("Map的key可以为任意类型的值；")]),t._v(" "),a("li",[t._v("new一个Map就是新实例化了一个Map；")]),t._v(" "),a("li",[t._v("对同一个key值进行多次赋值，后面的会覆盖前面的；")]),t._v(" "),a("li",[t._v("未被set的Map关键字使用get方法会返回"),a("code",[t._v("undefined")]),t._v(";")]),t._v(" "),a("li",[t._v("Map 的键是跟内存地址绑定的，引用类型数据需要指向同一个地址才是同一个键；")]),t._v(" "),a("li",[t._v("原始数据类型，只要他们的值严格相等，Map 将其视为一个键；")]),t._v(" "),a("li",[t._v("NaN不严格相等于自身，但 Map 将其视为同一个键；")]),t._v(" "),a("li",[t._v("undefined和null是两个不同的键")])]),t._v(" "),a("p",[t._v("set() get()  has()  delete() clear() size")]),t._v(" "),a("p",[t._v("Map的遍历(迭代)\nfor...of  for (var [key, value] of myMap)\nforEach()")]),t._v(" "),a("p",[t._v("Map结构可以通过扩展运算符(...)转为数组   [...myMap]")]),t._v(" "),a("p",[t._v("Map 的克隆")]),t._v(" "),a("p",[t._v("Map 的合并\nvar myMap = new Map([...myMap1, ...myMap2]);")]),t._v(" "),a("h3",{attrs:{id:"set结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#set结构"}},[t._v("#")]),t._v(" Set结构")]),t._v(" "),a("p",[t._v("Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。")]),t._v(" "),a("p",[t._v('-Set允许存储任何类型的唯一值，但Set()不能接收Object、Boolean和NaN，使用add()方法可添加任意类型值； -向 Set 加入值的时候，不会发生类型转换，所以123和"123"是两个不同的值； -Set 内部使用“===”来判断两个值是否相等，但是NaN是个特例 -引用类型得地址指向相同才是唯一值，Symbol得用变量存储才能被has()取到 -+0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复； -undefined 与 undefined 是恒等的，所以不重复； -Set 结构的键名就是键值')]),t._v(" "),a("p",[t._v("Set()是一个构造函数，需要用new来实例化，Set()构造函数可以接收一个具有 iterable 接口的其他数据结构（如数组，Map和Set结构等数据），其他类型会报错")]),t._v(" "),a("ul",[a("li",[t._v("Set.prototype.add(value)：添加某个值，返回 Set 结构本身。")]),t._v(" "),a("li",[t._v("Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。")]),t._v(" "),a("li",[t._v("Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。")]),t._v(" "),a("li",[t._v("Set.prototype.clear()：清除所有成员，没有返回值。")])]),t._v(" "),a("p",[a("strong",[t._v("for...of")])]),t._v(" "),a("p",[t._v("Set结构原生提供三个遍历器生成函数： -Set.prototype.keys()：返回键名的遍历器。 -Set.prototype.values()：返回键值的遍历器。 -Set.prototype.entries()：返回所有成员的遍历器。")]),t._v(" "),a("p",[t._v("Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法，因此可以省略values方法，直接用for...of循环遍历 Set。")]),t._v(" "),a("p",[a("strong",[t._v("forEach()")])]),t._v(" "),a("p",[t._v("set.forEach((value, key) => console.log(key + ' : ' + value))")]),t._v(" "),a("p",[a("strong",[t._v("Set的应用场景")])]),t._v(" "),a("ul",[a("li",[t._v("数组去重")]),t._v(" "),a("li",[t._v("字符串去重")]),t._v(" "),a("li",[t._v("求数组并集")]),t._v(" "),a("li",[t._v("求数组交集")]),t._v(" "),a("li",[t._v("求数组差集")])]),t._v(" "),a("h2",{attrs:{id:"_7-proxy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-proxy"}},[t._v("#")]),t._v(" 7. Proxy")]),t._v(" "),a("p",[t._v("一个 Proxy 对象包装另一个对象并拦截诸如读取/写入属性和其他操作，可以选择自行处理它们，或者透明地允许该对象处理它们。")]),t._v(" "),a("p",[t._v("对 proxy 的实例化需要两个参数, target 代表需要被代理的对象, handlers 代表对该代理对象的各种操作行为处理")]),t._v(" "),a("p",[t._v("let proxy = new Proxy(target, handler)")]),t._v(" "),a("p",[t._v("早期可以用 getter, setter, 但是每个代理属性都要编写对应的 getter, setter, 而且需要存在一个存储真实值的键, 否则会递归溢出")]),t._v(" "),a("h2",{attrs:{id:"_8-reflect对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-reflect对象"}},[t._v("#")]),t._v(" 8. Reflect对象")]),t._v(" "),a("p",[t._v("Reflect 是一个内置对象，可简化的创建 Proxy。")]),t._v(" "),a("p",[t._v("以前的内部方法，比如[[Get]]，[[Set]] 等等都只是规范，不能直接调用。")]),t._v(" "),a("p",[t._v("Reflect 对象使调用这些内部方法成为可能。它的方法是内部方法的最小包装。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" user "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nReflect"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("set")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("user"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'name'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'John'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("alert")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("user"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// John")]),t._v("\n")])])]),a("p",[t._v("尤其是，Reflect 允许我们使用函数（Reflect.construct，Reflect.deleteProperty，……）执行操作（new，delete，……）。这是一个有趣的功能，但是这里还有一点很重要。")]),t._v(" "),a("p",[t._v("对于每个可被 Proxy 捕获的内部方法，Reflect 都有一个对应的方法 Reflect，其名称和参数与 Proxy 钩子相同。")]),t._v(" "),a("h2",{attrs:{id:"_9-promise-手撕promise-a-规范、promise-all、promise相关api和方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-promise-手撕promise-a-规范、promise-all、promise相关api和方法"}},[t._v("#")]),t._v(" 9. Promise（手撕Promise A+规范、Promise.all、Promise相关API和方法）")]),t._v(" "),a("p",[t._v("静态方法：Promise.resolve\nPromise.reject\nPromise.all\nPromise.race")]),t._v(" "),a("p",[t._v("Promise是异步编程的一种解决方案，比起传统的解决方案（回调函数和事件），它显得更加的强大和方便（具体请看下文）。从语法上来讲，Promise是一个对象，从它可以获取异步操作的消息。Promise对象提供统一的API，各种异步操作都可以用同样的方法进行处理。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" p1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Promise")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("resolve"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" reject")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在这里做一些逻辑处理")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果异步操作成功的时候，调用resolve")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("resolve")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'success'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 操作失败后我们就调用reject()")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("reject")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'fail'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\np1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("then")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("val")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("val"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// success")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("err")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("err"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n")])])]),a("p",[t._v("我们可以看到Promise是一个构造函数，用来生成Promise实例，它接收一个函数作为参数，这个函数有两个参数——resolve和reject（它们也是两个函数，已经由JavaScript引擎提供，不用自己部署）。\n我们经常会在这个函数里处理一些逻辑，如果处理成功后我们会执行resolve（将状态从“未完成”转为“完成”），失败后执行reject（将状态从“未完成”转换为“失败”）。")]),t._v(" "),a("p",[a("strong",[t._v("三个状态")])]),t._v(" "),a("ul",[a("li",[t._v("pedding(未完成)")]),t._v(" "),a("li",[t._v("resolved(完成)")]),t._v(" "),a("li",[t._v("rejected(失败)")])]),t._v(" "),a("h2",{attrs:{id:"_10-iterator和for-of-iterator遍历器的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-iterator和for-of-iterator遍历器的实现"}},[t._v("#")]),t._v(" 10. Iterator和for...of（Iterator遍历器的实现）")]),t._v(" "),a("p",[a("strong",[t._v("Symbol.iterator")])]),t._v(" "),a("p",[t._v("在可被 for...of 迭代遍历的数据集合的原型链中都存在该属性为 key 的方法。")]),t._v(" "),a("p",[t._v("还有一些特殊的数据类型，类似数组对象 TypedArray，比如：函数参数集合 arguments")]),t._v(" "),a("p",[t._v("类似数组对象的定义：有 length 属性和若干索引属性对象。")]),t._v(" "),a("p",[t._v("并不是所有类似数组对象都存在 Iterator 接口，可以使用 Array.from() 将其转为数组。")]),t._v(" "),a("p",[t._v("遍历器(iterator)属性是一种接口，为各种数据结构提供一个统一的访问机制。不管何种数据结构，只要部署了 Iterator 接口，就能完成遍历操作 。")]),t._v(" "),a("p",[a("strong",[t._v("作用：")])]),t._v(" "),a("ul",[a("li",[t._v("为各种数据结构提供一个便捷的、统一的访问接口；")]),t._v(" "),a("li",[t._v("使得数据结构的成员 item 按照次序排列；")]),t._v(" "),a("li",[t._v("主要提供给 for...of 消费")])]),t._v(" "),a("p",[a("strong",[t._v("遍历过程：")])]),t._v(" "),a("ul",[a("li",[t._v("创建一个指针对象，指向当前数据结构起始位置。遍历器对象本质上就是一个指针对象。")]),t._v(" "),a("li",[t._v("第一次调用指针对象的 next 方法，指针就指向第一个成员。")]),t._v(" "),a("li",[t._v("第二次调用 next 方法，指针就指向第二个成员。")]),t._v(" "),a("li",[t._v("......循环执行第三步，直到指针指向该数据结构结束位置。")])]),t._v(" "),a("p",[t._v("next 方法返回的对象结构：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("next")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        value"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" item"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当前下标指向的位置成员")]),t._v("\n        done"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Boolean"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 遍历是否结束，true 为结束")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'1'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'2'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'3'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" iter "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Symbol"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("iterator"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 执行数组的 iterator 属性方法")]),t._v("\n\niter"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("next")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// { value: '1', done: false }")]),t._v("\niter"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("next")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// { value: '2', done: false }")]),t._v("\niter"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("next")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// { value: '3', done: false }")]),t._v("\niter"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("next")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// { value: undefined, done: true }")]),t._v("\n\n")])])]),a("h3",{attrs:{id:"在什么情况下会调用-symbol-iterator-接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#在什么情况下会调用-symbol-iterator-接口"}},[t._v("#")]),t._v(" 在什么情况下会调用 Symbol.iterator 接口")]),t._v(" "),a("ol",[a("li",[t._v("对数组或者 Set 数据类型解构赋值时会默认触发；")]),t._v(" "),a("li",[t._v("扩展运算符也会默认调用 Iterator 接口，可以利用该特性将部署了 Iterator 接口的对象使用扩展运算符转为数组；")]),t._v(" "),a("li",[t._v("yield* 后面跟一个可遍历结构数据也会默认触发；")]),t._v(" "),a("li",[t._v("所有接受数组为参数的方法都调用了遍历器接口")])]),t._v(" "),a("ul",[a("li",[t._v("Array.from")]),t._v(" "),a("li",[t._v("for...of")]),t._v(" "),a("li",[t._v("Promise.all")]),t._v(" "),a("li",[t._v("Promise.race")]),t._v(" "),a("li",[t._v("Map Set WeakMap WeakSet")])]),t._v(" "),a("p",[a("strong",[t._v("Symbol.iterator 就是为了给 for...of 循环提供一个统一的遍历接口，for...of 能遍历所有提供了 Symbol.iterator 接口的数据集合；for...of 也是为了让遍历更优雅，提升代码的可读性，毕竟 for...of 的写法比起 for 表达式更简洁。")])]),t._v(" "),a("h2",{attrs:{id:"_11-循环语法比较及使用场景-for、foreach、for-in、for-of"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-循环语法比较及使用场景-for、foreach、for-in、for-of"}},[t._v("#")]),t._v(" 11. 循环语法比较及使用场景（for、forEach、for...in、for...of）")]),t._v(" "),a("h3",{attrs:{id:"for-in"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#for-in"}},[t._v("#")]),t._v(" for...in：")]),t._v(" "),a("p",[t._v("var a = [1,2,3];")]),t._v(" "),a("p",[t._v("for (var k in a) {}")]),t._v(" "),a("p",[t._v("我们都知道，for...in 遍历返回的是键名，数组的键名应该是数字，但是 for...in 在遍历数组的时候却是返回的字符串；")]),t._v(" "),a("p",[t._v("for...in 不仅遍历数字键名，还会遍历手动添加的其它键，甚至包括原型链上的键；")]),t._v(" "),a("p",[t._v("某些情况下，for...in 循环会以任意顺序遍历键名；")]),t._v(" "),a("h3",{attrs:{id:"foreach"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#foreach"}},[t._v("#")]),t._v(" forEach：")]),t._v(" "),a("p",[t._v("a.forEach(function(item){}")]),t._v(" "),a("p",[t._v("这种循环方式 break 命令无效，无法跳出循环，只能利用 return 跳出当次循环；")]),t._v(" "),a("h3",{attrs:{id:"for"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#for"}},[t._v("#")]),t._v(" for：")]),t._v(" "),a("p",[t._v("这种方式都知道的，最基础的循环，for (var i = 0; i < 10; i++) { } 一眼过去就知道用这种方式循环还是比较麻烦的；")]),t._v(" "),a("h3",{attrs:{id:"for-of"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#for-of"}},[t._v("#")]),t._v(" for...of：")]),t._v(" "),a("ul",[a("li",[t._v("和 for...in 一样的简洁语法，但是没有对应的缺点；")]),t._v(" "),a("li",[t._v("与 forEach 不同，break continue 和 return 可以配合使用；")]),t._v(" "),a("li",[t._v("提供遍历所有数据结构统一的接口；")])]),t._v(" "),a("h2",{attrs:{id:"_12-generator及其异步方面的应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-generator及其异步方面的应用"}},[t._v("#")]),t._v(" 12. Generator及其异步方面的应用")]),t._v(" "),a("p",[t._v("当我们写一个函数 在function后面或者函数名字前面加上一个* 调用这个函数返回的就是Generator 而这个函数称为Generator函数")]),t._v(" "),a("p",[t._v("gen函数体内，我们用同步代码的写法，实现了异步操作。可以看到，用gererator来执行异步操作，在代码可读性、可扩展性上面，是很有优势的。")]),t._v(" "),a("h2",{attrs:{id:"_13-async函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-async函数"}},[t._v("#")]),t._v(" 13. async函数")]),t._v(" "),a("p",[t._v("我们知道，调用Generator函数不会立即执行，而是返回遍历器对象。疲于手动执行遍历器对象，因此就有了thunk(thunkify)函数结合run函数来实现自动流程管理。或者，使用co模块来实现自动流程管理，使Generator函数的使用更加方便。")]),t._v(" "),a("p",[t._v("而async函数ES2017标准引入的语法，是Generator函数的语法糖，因此其相对于Generator函数，具有以下基本特点。")]),t._v(" "),a("p",[a("strong",[t._v("内置执行器：")]),t._v(" 使用async函数可以像使用普通函数一样，直接调用即可执行。不用像Generator函数一样使用co模块来实现流程控制。")]),t._v(" "),a("p",[a("strong",[t._v("语义化更强")]),t._v(":async关键字表示是一个异步的函数，await表示需要等待执行。相对于yield表达式，语义化更强。")]),t._v(" "),a("p",[a("strong",[t._v("返回值是Promise")]),t._v("： async函数返回值是Promise对象，这比Generator函数的返回值是Iterator对象方便多了，可以使用then方法来指定下一步的操作。")]),t._v(" "),a("p",[t._v("使用async关键字表明函数是一个async函数，内部使用await关键字表明需要等待异步任务结束后才继续往下执行。")]),t._v(" "),a("ol",[a("li",[t._v("async函数是基于Generator函数实现的，是Generator函数的语法糖。其内置执行器，调用后返回Promise对象，因此可以像普通韩式一样使用。")]),t._v(" "),a("li",[t._v("async函数内部抛出错误或者await关键字后面的表达式抛出错误，会使async函数返回的Promise对象从pending状态变为reject状态，从而可以被catch方法捕获错误。而且，Promise对象的状态一旦改变就不会再变，之后的异步任务就不会执行了。")]),t._v(" "),a("li",[t._v("await关键字后面的表达式可以是Promise对象，也可以是其他数据类型。如果是其他数据类型，则会通过Promise.resolve将其转换为Promise对象")]),t._v(" "),a("li",[t._v("async函数内部如果有多个await关键字，其后的异步任务会继发执行。如果每一个异步任务不相互依赖，则可以使用Promise.all让其并发执行，这样可以在同样的时间里完成多个异步任务，提高函数执行效率。")]),t._v(" "),a("li",[t._v("对于async内部抛出的错误，可以使用try...catch来捕获异常。虽然try...catch只能用于捕获同步任务，但是await关键字可以使得异步任务同步化,因此可以结合try...catch和await关键字捕获异步任务。")])]),t._v(" "),a("h2",{attrs:{id:"_14-几种异步方式的比较-回调、settimeout、promise、generator、async"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-几种异步方式的比较-回调、settimeout、promise、generator、async"}},[t._v("#")]),t._v(" 14. 几种异步方式的比较（回调、setTimeout、Promise、Generator、async）")]),t._v(" "),a("p",[a("strong",[t._v("回调")])]),t._v(" "),a("p",[a("strong",[t._v("setTimeout")])]),t._v(" "),a("p",[a("strong",[t._v("Promise")])]),t._v(" "),a("p",[a("strong",[t._v("Generator")])]),t._v(" "),a("p",[a("strong",[t._v("async")])]),t._v(" "),a("h2",{attrs:{id:"_15-class基本语法及继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15-class基本语法及继承"}},[t._v("#")]),t._v(" 15. class基本语法及继承")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MyClass")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// class 方法")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("method1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("method2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("method3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("继承")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Point")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ColorPoint")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Point")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" color")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("super")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("color "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" color\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[t._v("父类的静态方法也会被子类继承")]),t._v(" "),a("p",[t._v("关键字——super")]),t._v(" "),a("p",[t._v("super代表的是父类构造函数，但是返回的是子类的实例。比如A是B的父类，那么super的功能相当于A.prototype.constructor.call(this)。")]),t._v(" "),a("p",[t._v("super的使用方式：1、当函数使用。2、当对象使用")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当函数使用")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("A")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("B")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("A")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("super")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当对象使用")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("A")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("p")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("B")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("A")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("super")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("super")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("p")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 2")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" b "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("B")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n\n")])])]),a("h2",{attrs:{id:"_16-模块加载方案比较-commonjs和es6的module"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16-模块加载方案比较-commonjs和es6的module"}},[t._v("#")]),t._v(" 16. 模块加载方案比较（CommonJS和ES6的Module）")]),t._v(" "),a("p",[t._v("CommonJS导出的是对象，内部要导出的变量在导出的那一刻就已经赋值给对象的属性了，也就有了“CommonJS输出的是值的拷贝”这种说法，后面再在模块里修改变量，其他模块是感觉不到的，因为已经没有关系了。但是对象还是会影响，因为对象拷贝的只是对象的引用。")]),t._v(" "),a("p",[t._v("也是因为CommonJS导出的是对象，在编译阶段不会读取对象的内容，并不清楚对象内部都导出了哪些变量、这些变量是不是从别的文件导入进来的。只有等到代码运行时才能访问对象的属性，确定依赖关系。因此才说CommonJS的模块是动态加载的。")]),t._v(" "),a("p",[t._v("而对ES6 Module来说，由于内部对每个变量都定义了getter，因此其他模块导入后访问变量时触发getter，返回模块里的同名变量，如果变量值发生变化，则外边的引用也会变化。")]),t._v(" "),a("p",[t._v("但是export default没有走getter的形式，也是直接赋值，所以输出的也是一份拷贝。")]),t._v(" "),a("p",[t._v("ES6 Module导出的不是一个对象，导出的是一个个接口，因此在编译时就能确定模块之间的依赖关系，所以才说ES6 Module是静态加载的。Tree Shaking就是根据这个特性在编译阶段摇掉无用模块的。")]),t._v(" "),a("p",[t._v("ES6 Module还提供了一个import()方法动态加载模块，返回一个Promise。")]),t._v(" "),a("h2",{attrs:{id:"_17-es6模块加载与commonjs加载的原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_17-es6模块加载与commonjs加载的原理"}},[t._v("#")]),t._v(" 17. ES6模块加载与CommonJS加载的原理")])])}),[],!1,null,null,null);s.default=e.exports}}]);