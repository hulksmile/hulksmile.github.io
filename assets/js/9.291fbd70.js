(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{364:function(t,_,v){"use strict";v.r(_);var a=v(45),s=Object(a.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"http与计算机网络"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http与计算机网络"}},[t._v("#")]),t._v(" HTTP与计算机网络")]),t._v(" "),v("h2",{attrs:{id:"_1-tcp-ip协议分层管理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-tcp-ip协议分层管理"}},[t._v("#")]),t._v(" 1. TCP/IP协议分层管理")]),t._v(" "),v("p",[t._v("###网络基础TCP/IP\n网络七层协议是OSI是一个开放性的通信系统互连参考模型；而基于TCP/IP的参考模型将协议分成四个层次。")]),t._v(" "),v("p",[t._v("注意，这里说的是基于TCP/IP的参考模型将协议是四层，而且七层指的是OSI网络分层协议。基于TCP/IP的参考模型已经说明自己是TCP/IPl ，而且将表示层和会话层合并，所以看起来就是四层。下面显示两者的不同：\n我们通常所使用的网络（包括互联网）均是在TCP/IP协议族的基础上运作的。HTTP属于它内部的一个子集")]),t._v(" "),v("p",[t._v("TCP/IP协议族按层次分为：应用层，传输层，网络层和数据链路层（更好的划分方法应该是将网络划分为7层）\n"),v("img",{attrs:{src:"/TCPIP%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82%E7%AE%A1%E7%90%86457.png",alt:"TCPIP协议分层管理457"}}),t._v("\n理解四层：")]),t._v(" "),v("p",[v("strong",[t._v("应用层")]),t._v("：决定了向用户提供应用服务时的通信的活动。HTTP协议处于应用层")]),t._v(" "),v("p",[v("strong",[t._v("传输层")]),t._v("：传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。传输层有两个性质不同的协议：TCP（传输         控制器协议）和UDP（用户数据报协议）")]),t._v(" "),v("p",[v("strong",[t._v("网络层(又名网络互联层)")]),t._v("：用来处理在网络上流动的数据包。\n与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。")]),t._v(" "),v("p",[v("strong",[t._v("链路层（数据链路层，网络接口层）")]),t._v("：用来处理网络连接的硬件部分\n发送端从应用层往下走，每经过一层时必定会打上一个该层所属的首部信息。接收端则往应用层上走，每经过一层时会把对应的首部消去。数据包装的这种方法称为：封装")]),t._v(" "),v("p",[t._v("例证：以访问某个web页面为例\n"),v("img",{attrs:{src:"/TCPIP%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82%E7%AE%A1%E7%90%86.png",alt:"TCPIP协议分层管理"}})]),t._v(" "),v("p",[v("strong",[t._v("发送端：")])]),t._v(" "),v("p",[t._v("应用层：客户端在应用层依据HTTP协议发出想访问web页面的HTTP请求")]),t._v(" "),v("p",[t._v("传输层：依据TCP协议将从应用层收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号后发给             网络层")]),t._v(" "),v("p",[t._v("网络层：IP协议，增加作为通信目的地的MAC地址后转发给链路层。")]),t._v(" "),v("p",[t._v("至此，发往网络的通信请求就准备齐全了")]),t._v(" "),v("p",[v("strong",[t._v("接收端：")]),t._v("\n接收端的服务器在链路层上接收到数据，按序往上层发送，一直到应用层。\n直到传输到应用层，才算真正接收到由客户端发送过来的HTTP请求。")]),t._v(" "),v("ol",[v("li",[v("strong",[t._v("应用层")]),t._v("\nOSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。")]),t._v(" "),v("li",[v("strong",[t._v("表示层")]),t._v("\n表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。")]),t._v(" "),v("li",[v("strong",[t._v("会话层")]),t._v("\n会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。")]),t._v(" "),v("li",[v("strong",[t._v("传输层")]),t._v("\n传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。")]),t._v(" "),v("li",[v("strong",[t._v("网络层")]),t._v("\n本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。")]),t._v(" "),v("li",[v("strong",[t._v("数据链路层")]),t._v("\n将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。")]),t._v(" "),v("li",[v("strong",[t._v("物理层")]),t._v("\n实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。")])]),t._v(" "),v("h2",{attrs:{id:"_2-三次握手四次挥手机制及原因"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-三次握手四次挥手机制及原因"}},[t._v("#")]),t._v(" 2. 三次握手四次挥手机制及原因")]),t._v(" "),v("h3",{attrs:{id:"tcp-三次握手的过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp-三次握手的过程"}},[t._v("#")]),t._v(" TCP 三次握手的过程")]),t._v(" "),v("p",[v("strong",[t._v("目的是为了确认对方的发送与接收能力")]),t._v(" "),v("img",{attrs:{src:"/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png",alt:"三次握手"}}),t._v("\n客户端发送 SYN, 服务端接收到了后返回一个SYN和ACK, 然后客户端发送Ack, 服务端接收到后握手完成")]),t._v(" "),v("ul",[v("li",[v("p",[v("strong",[t._v("第一次握手：")]),t._v("\n客户端将TCP报文标志位SYN置为1，随机产生一个序号值seq=J，保存在TCP首部的序列号(Sequence Number)字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入SYN_SENT状态，等待服务器端确认。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("第二次握手：")]),t._v("\n服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将TCP报文标志位SYN和ACK都置为1，ack=J+1，随机产生一个序号值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("第三次握手：")]),t._v("\n客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。")])]),t._v(" "),v("li",[v("p",[t._v("为什么不是两次, 没法确认客户端的接收")])]),t._v(" "),v("li",[v("p",[t._v("为什么不是四次, 已经确认好了没必要了")])]),t._v(" "),v("li",[v("p",[t._v("能否携带数据, 第三次可以")])])]),t._v(" "),v("h3",{attrs:{id:"tcp-四次挥手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp-四次挥手"}},[t._v("#")]),t._v(" TCP 四次挥手")]),t._v(" "),v("p",[t._v("状态: 都处于 ESTABLISHED")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("第一次挥手")]),t._v("： Client端发起挥手请求，向Server端发送标志位是FIN报文段，设置序列号seq，此时，Client端进入FIN_WAIT_1状态，这表示Client端没有数据要发送给Server端了。")]),t._v(" "),v("li",[v("strong",[t._v("第二次分手")]),t._v("：Server端收到了Client端发送的FIN报文段，向Client端返回一个标志位是ACK的报文段，ack设为seq加1，Client端进入FIN_WAIT_2状态，Server端告诉Client端，我确认并同意你的关闭请求。")]),t._v(" "),v("li",[v("strong",[t._v("第三次分手")]),t._v("： Server端向Client端发送标志位是FIN的报文段，请求关闭连接，同时Client端进入LAST_ACK状态。")]),t._v(" "),v("li",[v("strong",[t._v("第四次分手")]),t._v(" ： Client端收到Server端发送的FIN报文段，向Server端发送标志位是ACK的报文段，然后Client端进入TIME_WAIT状态。Server端收到Client端的ACK报文段以后，就关闭连接。此时，Client端等待2MSL的时间后依然没有收到回复，则证明Server端已正常关闭，那好，Client端也可以关闭连接了。\n"),v("img",{attrs:{src:"/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png",alt:"四次挥手"}}),t._v("\n要断开的端: FIN_wait1, fin_wait2, time_wait, closed")])]),t._v(" "),v("p",[t._v("被断开的端: close_wait, last_ack, closed")]),t._v(" "),v("p",[t._v("客户端要断开, 发送 FIN 报文之后客户端只能接收无法发送报文, 服务端先发送确认再发送FIN, 客户端收到后发送ACK, 若一段时间内没有收到服务器的重发请求, 就结束, 否则重发ACK")]),t._v(" "),v("p",[v("strong",[t._v("目的是: 客户端和服务端都断开连接, 两端都不浪费资源等待, 要发送的数据全发完")])]),t._v(" "),v("ul",[v("li",[t._v("为什么要等待 2MSL, 防止之后启用了相同端口的新应用接收到无用的信息")]),t._v(" "),v("li",[t._v("MSL, 最大存活时间, A 去向 ACK 和来向 FIN 的时间相加, 保证服务端收到了消息")]),t._v(" "),v("li",[t._v("为什么是四次不是三次, 防止服务端有报文没有发送完")]),t._v(" "),v("li",[t._v("为什么客户端还要发送 Ack, 为了让服务端直到客户端收到了 FIN, 防止因为网络故障服务端没有收到")])]),t._v(" "),v("h2",{attrs:{id:"_3-http方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-http方法"}},[t._v("#")]),t._v(" 3. HTTP方法")]),t._v(" "),v("ul",[v("li",[t._v("GET, 从指定资源请求数据")]),t._v(" "),v("li",[t._v("POST, 向指定的 URI 提交要给处理的数据")]),t._v(" "),v("li",[t._v("PUT, 上传指定的 URI ，表示PUT方法会向服务器写入文档。PUT方法的语义就是让服务器用请求的主体部分来创建一个由所请求的URL命名的新闻的，或者替换已存在的URL")]),t._v(" "),v("li",[t._v("HEAD, 与 GET 相同, 但只返回 HTTP 报头\n在不获取资源的情况下了解资源的情况（比如：判断其类型）；\n通过查看响应的状态码，看看某个对象是否存在；\n通过查看首部，测试资源是否被修改了")]),t._v(" "),v("li",[t._v("DELETE, 删除指定资源")]),t._v(" "),v("li",[t._v("OPTIONS, 返回服务器支持的 HTTP 方法, 还有 cors 预检请求")])]),t._v(" "),v("h3",{attrs:{id:"post-与-put-区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#post-与-put-区别"}},[t._v("#")]),t._v(" post 与 put 区别")]),t._v(" "),v("p",[t._v("本质都是语义, put 相当于上传一个 entity 实体上去, post 是提交要被处理的数据")]),t._v(" "),v("h2",{attrs:{id:"_4-get和post的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-get和post的区别"}},[t._v("#")]),t._v(" 4. GET和POST的区别")]),t._v(" "),v("p",[t._v("我们在提交表单时有两种方式，一样get，二为post. 它们都是把相关的数据提交给服务端。即设置表单method为get或post即可。")]),t._v(" "),v("p",[t._v("GET产生一个TCP数据包；POST产生两个TCP数据包。\n它们的区别为：")]),t._v(" "),v("ul",[v("li",[t._v("GET在浏览器回退时是无害的，而POST会再次提交请求。")]),t._v(" "),v("li",[t._v("GET产生的URL地址可以被Bookmark，而POST不可以。")]),t._v(" "),v("li",[t._v("GET请求会被浏览器主动cache，而POST不会，除非手动设置。")]),t._v(" "),v("li",[t._v("GET请求只能进行url编码，而POST支持多种编码方式。")]),t._v(" "),v("li",[t._v("GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。")]),t._v(" "),v("li",[t._v("GET请求在URL中传送的参数是有长度限制的，而POST么有。")]),t._v(" "),v("li",[t._v("对参数的数据类型，GET只接受ASCII字符，而POST没有限制。")]),t._v(" "),v("li",[t._v("GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。")]),t._v(" "),v("li",[t._v("GET参数通过URL传递，POST放在Request body中。")])]),t._v(" "),v("h2",{attrs:{id:"_5-http建立持久连接的意义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-http建立持久连接的意义"}},[t._v("#")]),t._v(" 5. HTTP建立持久连接的意义")]),t._v(" "),v("p",[t._v("启用Keep-Alive模式肯定更高效，性能更高。因为避免了建立/释放连接的开销。\n重用TCP连接可以加速数据传输，因为：\n使用过的连接会比新建立的连接速度会快一些，这是由于TCP连接慢启动的特性，每次建立新的连接，当然不如已经被调教的很好的连接速度快咯。")]),t._v(" "),v("h2",{attrs:{id:"_6-http报文的结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-http报文的结构"}},[t._v("#")]),t._v(" 6. HTTP报文的结构")]),t._v(" "),v("h3",{attrs:{id:"请求报文"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#请求报文"}},[t._v("#")]),t._v(" 请求报文")]),t._v(" "),v("ul",[v("li",[t._v("第一行是方法, 路径, http 版本")]),t._v(" "),v("li",[t._v("然后是 headers")]),t._v(" "),v("li",[t._v("如果有数据的话会有请求体")])]),t._v(" "),v("h3",{attrs:{id:"返回报文"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#返回报文"}},[t._v("#")]),t._v(" 返回报文")]),t._v(" "),v("ul",[v("li",[t._v("第一行是 http 版本, 状态码, 状态信息")]),t._v(" "),v("li",[t._v("headers")]),t._v(" "),v("li",[t._v("资源体0")])]),t._v(" "),v("h2",{attrs:{id:"_7-http状态码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-http状态码"}},[t._v("#")]),t._v(" 7. HTTP状态码")]),t._v(" "),v("h3",{attrs:{id:"常见"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常见"}},[t._v("#")]),t._v(" 常见：")]),t._v(" "),v("ul",[v("li",[t._v("200 - 请求成功")]),t._v(" "),v("li",[t._v("301 - 资源（网页等）被永久转移到其它URL")]),t._v(" "),v("li",[t._v("404 - 请求的资源（网页等）不存在")]),t._v(" "),v("li",[t._v("500 - 内部服务器错误")])]),t._v(" "),v("h3",{attrs:{id:"普遍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#普遍"}},[t._v("#")]),t._v(" 普遍")]),t._v(" "),v("ul",[v("li",[t._v("1xx, 指客户端相应的动作, 代表请求已被接收, 需要继续处理")]),t._v(" "),v("li",[t._v("2xx, 代表请求已经成功被服务器接收处理了")]),t._v(" "),v("li",[t._v("3xx, 代表客户端采取进一步操作才能完成请求, 这些状态码用来重定向, 重定向地址在本次响应的 Location 中指明")]),t._v(" "),v("li",[t._v("4xx, 表示请求错误, 客户端的请求可能有问题")]),t._v(" "),v("li",[t._v("499, 客户端主动断开连接, 可能是跨域请求被拦截, 也可能是服务器被攻击")]),t._v(" "),v("li",[t._v("5xx, 代表服务器处理请求的过程中有错误, 也可能是无法完成请求的处理")]),t._v(" "),v("li",[t._v("504 bad gateway, 代理服务器的上游没法在规定时间内给出响应")]),t._v(" "),v("li",[t._v("cloudflare 524, cloudflare 可以请求到上游服务器但是上游服务器太长时间不应答, 超过了 timeout")])]),t._v(" "),v("h2",{attrs:{id:"_8-web服务器及其组成"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-web服务器及其组成"}},[t._v("#")]),t._v(" 8. Web服务器及其组成")]),t._v(" "),v("h2",{attrs:{id:"_9-http报文首部"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9-http报文首部"}},[t._v("#")]),t._v(" 9. HTTP报文首部")]),t._v(" "),v("h2",{attrs:{id:"_10-http通用首部字段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10-http通用首部字段"}},[t._v("#")]),t._v(" 10. HTTP通用首部字段")]),t._v(" "),v("h2",{attrs:{id:"_11-http请求首部字段、响应首部字段、实体首部字段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_11-http请求首部字段、响应首部字段、实体首部字段"}},[t._v("#")]),t._v(" 11. HTTP请求首部字段、响应首部字段、实体首部字段")]),t._v(" "),v("h2",{attrs:{id:"_12-cookie相关首部字段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_12-cookie相关首部字段"}},[t._v("#")]),t._v(" 12. Cookie相关首部字段")]),t._v(" "),v("h2",{attrs:{id:"_13-https与http区别及实现方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_13-https与http区别及实现方式"}},[t._v("#")]),t._v(" 13. HTTPS与HTTP区别及实现方式")]),t._v(" "),v("p",[t._v("超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。")]),t._v(" "),v("p",[t._v("HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。")]),t._v(" "),v("p",[t._v("HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。")]),t._v(" "),v("p",[t._v("简而言之: HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版")]),t._v(" "),v("h3",{attrs:{id:"http-与-https-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-与-https-的区别"}},[t._v("#")]),t._v(" HTTP 与 HTTPS 的区别")]),t._v(" "),v("ul",[v("li",[t._v("HTTP 是明文传输，HTTPS 通过 SSL\\TLS 进行了加密")]),t._v(" "),v("li",[t._v("HTTP 的端口号是 80，HTTPS 是 443")]),t._v(" "),v("li",[t._v("HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费")]),t._v(" "),v("li",[t._v("HTTP 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。")])]),t._v(" "),v("p",[t._v("HTTPS主要作用是：")]),t._v(" "),v("p",[t._v("对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全")]),t._v(" "),v("p",[t._v("对网站服务器进行真实身份认证")]),t._v(" "),v("h2",{attrs:{id:"_14-cookie与session"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-cookie与session"}},[t._v("#")]),t._v(" 14. Cookie与Session")]),t._v(" "),v("h2",{attrs:{id:"_15-基于http的功能追加协议-spy、websocket、http"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_15-基于http的功能追加协议-spy、websocket、http"}},[t._v("#")]),t._v(" 15. 基于HTTP的功能追加协议（SPY、WebSocket、HTTP）")]),t._v(" "),v("h2",{attrs:{id:"_16-常见的web攻击分类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_16-常见的web攻击分类"}},[t._v("#")]),t._v(" 16. 常见的Web攻击分类")]),t._v(" "),v("h2",{attrs:{id:"_17-tcp与udp区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_17-tcp与udp区别"}},[t._v("#")]),t._v(" 17. TCP与UDP区别")]),t._v(" "),v("h2",{attrs:{id:"_18-存储机制localstorage、sessionstorage与cookie存储技术"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_18-存储机制localstorage、sessionstorage与cookie存储技术"}},[t._v("#")]),t._v(" 18. 存储机制localStorage、sessionStorage与Cookie存储技术")]),t._v(" "),v("h2",{attrs:{id:"_19-xss攻击及防御"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_19-xss攻击及防御"}},[t._v("#")]),t._v(" 19. XSS攻击及防御")]),t._v(" "),v("h2",{attrs:{id:"_20-csrf攻击及防御"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_20-csrf攻击及防御"}},[t._v("#")]),t._v(" 20. CSRF攻击及防御")]),t._v(" "),v("h2",{attrs:{id:"_21-http缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_21-http缓存"}},[t._v("#")]),t._v(" 21. HTTP缓存")]),t._v(" "),v("h3",{attrs:{id:"强制缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#强制缓存"}},[t._v("#")]),t._v(" 强制缓存")]),t._v(" "),v("p",[t._v("当缓存数据库中已有所请求的数据时。客户端直接从缓存数据库中获取数据。当缓存数据库中没有所请求的数据时，客户端的才会从服务端获取数据。")]),t._v(" "),v("h3",{attrs:{id:"协商缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),v("p",[t._v("又称对比缓存，客户端会先从缓存数据库中获取到一个缓存数据的标识，得到标识后请求服务端验证是否失效（新鲜），如果没有失效服务端会返回304，此时客户端直接从缓存中获取所请求的数据，如果标识失效，服务端会返回更新后的数据。")])])}),[],!1,null,null,null);_.default=s.exports}}]);