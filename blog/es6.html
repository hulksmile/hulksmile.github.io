<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ES6 | hulksmile</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.35bcedcf.css" as="style"><link rel="preload" href="/assets/js/app.03c3e821.js" as="script"><link rel="preload" href="/assets/js/2.fef91045.js" as="script"><link rel="preload" href="/assets/js/13.46aa809f.js" as="script"><link rel="prefetch" href="/assets/js/10.38705d39.js"><link rel="prefetch" href="/assets/js/11.4206f2b3.js"><link rel="prefetch" href="/assets/js/12.03409474.js"><link rel="prefetch" href="/assets/js/14.282f939a.js"><link rel="prefetch" href="/assets/js/15.30e7d426.js"><link rel="prefetch" href="/assets/js/16.bb6e8dc5.js"><link rel="prefetch" href="/assets/js/3.5e04ea21.js"><link rel="prefetch" href="/assets/js/4.09ee8a39.js"><link rel="prefetch" href="/assets/js/5.30fca801.js"><link rel="prefetch" href="/assets/js/6.498ab014.js"><link rel="prefetch" href="/assets/js/7.91f7f8c5.js"><link rel="prefetch" href="/assets/js/8.025f27e6.js"><link rel="prefetch" href="/assets/js/9.291fbd70.js">
    <link rel="stylesheet" href="/assets/css/0.styles.35bcedcf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">hulksmile</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/JavaScript.html" class="nav-link">
  JavaScript
</a></div> <a href="https://github.com/hulksmile/hulksmile.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    My GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/JavaScript.html" class="nav-link">
  JavaScript
</a></div> <a href="https://github.com/hulksmile/hulksmile.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    My GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/" aria-current="page" class="sidebar-link">首页</a></li><li><a href="/blog/JavaScript.html" class="sidebar-link">JavaScript</a></li><li><a href="/blog/es6.html" aria-current="page" class="active sidebar-link">es6</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/es6.html#_1-let、const和var的概念与区别" class="sidebar-link">1. let、const和var的概念与区别</a></li><li class="sidebar-sub-header"><a href="/blog/es6.html#_2-变量提升与暂时性死区" class="sidebar-link">2. 变量提升与暂时性死区</a></li><li class="sidebar-sub-header"><a href="/blog/es6.html#_3-变量的结构赋值" class="sidebar-link">3. 变量的结构赋值</a></li><li class="sidebar-sub-header"><a href="/blog/es6.html#_4-箭头函数及其this问题" class="sidebar-link">4. 箭头函数及其this问题</a></li><li class="sidebar-sub-header"><a href="/blog/es6.html#_5-symbol概念及其作用" class="sidebar-link">5. Symbol概念及其作用</a></li><li class="sidebar-sub-header"><a href="/blog/es6.html#_6-set和map数据结构" class="sidebar-link">6. Set和Map数据结构</a></li><li class="sidebar-sub-header"><a href="/blog/es6.html#_7-proxy" class="sidebar-link">7. Proxy</a></li><li class="sidebar-sub-header"><a href="/blog/es6.html#_8-reflect对象" class="sidebar-link">8. Reflect对象</a></li><li class="sidebar-sub-header"><a href="/blog/es6.html#_9-promise-手撕promise-a-规范、promise-all、promise相关api和方法" class="sidebar-link">9. Promise（手撕Promise A+规范、Promise.all、Promise相关API和方法）</a></li><li class="sidebar-sub-header"><a href="/blog/es6.html#_10-iterator和for-of-iterator遍历器的实现" class="sidebar-link">10. Iterator和for...of（Iterator遍历器的实现）</a></li><li class="sidebar-sub-header"><a href="/blog/es6.html#_11-循环语法比较及使用场景-for、foreach、for-in、for-of" class="sidebar-link">11. 循环语法比较及使用场景（for、forEach、for...in、for...of）</a></li><li class="sidebar-sub-header"><a href="/blog/es6.html#_12-generator及其异步方面的应用" class="sidebar-link">12. Generator及其异步方面的应用</a></li><li class="sidebar-sub-header"><a href="/blog/es6.html#_13-async函数" class="sidebar-link">13. async函数</a></li><li class="sidebar-sub-header"><a href="/blog/es6.html#_14-几种异步方式的比较-回调、settimeout、promise、generator、async" class="sidebar-link">14. 几种异步方式的比较（回调、setTimeout、Promise、Generator、async）</a></li><li class="sidebar-sub-header"><a href="/blog/es6.html#_15-class基本语法及继承" class="sidebar-link">15. class基本语法及继承</a></li><li class="sidebar-sub-header"><a href="/blog/es6.html#_16-模块加载方案比较-commonjs和es6的module" class="sidebar-link">16. 模块加载方案比较（CommonJS和ES6的Module）</a></li><li class="sidebar-sub-header"><a href="/blog/es6.html#_17-es6模块加载与commonjs加载的原理" class="sidebar-link">17. ES6模块加载与CommonJS加载的原理</a></li></ul></li><li><a href="/blog/HTML-CSS.html" class="sidebar-link">HTML-CSS</a></li><li><a href="/blog/HTTP与计算机网络.html" class="sidebar-link">HTTP与计算机网络</a></li><li><a href="/blog/前端工程化.html" class="sidebar-link">前端工程化</a></li><li><a href="/blog/NodeJS.html" class="sidebar-link">NodeJS</a></li><li><a href="/blog/需要会手撕的代码部分.html" class="sidebar-link">需要会手撕的代码部分</a></li><li><a href="/blog/VUE.html" class="sidebar-link">VUE</a></li><li><a href="/blog/计算机基础.html" class="sidebar-link">计算机基础</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="es6"><a href="#es6" class="header-anchor">#</a> ES6</h1> <h2 id="_1-let、const和var的概念与区别"><a href="#_1-let、const和var的概念与区别" class="header-anchor">#</a> 1. let、const和var的概念与区别</h2> <p>let、const 是 ES6 新增的两个声明变量的命令，用法类似于于 var。
var 声明的变量会提升到当前作用域的最顶端，注意只提升声明，不提升赋值。</p> <p>let 不存在变量提升</p> <p>只要是 let 声明的变量会“绑定”到当前作用域，不会受外部影响，在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”，总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p> <p>let 不允许同一作用域内重复声明同一个变量，var可以重复声明。</p> <p>因此，函数内部不能使用let重复声明参数</p> <p>var、function属于全局变量，是顶层对象的属性，let、const、class 不属于顶层对象属性，不可通过window.去访问</p> <p>const 声明一个只读的常量，一旦被声明就不允许改变。</p> <p>const和let一样声明只在块级作用域有效，同样没有变量提升，和存在暂时性死区，也不可重复声明</p> <p>我们都知道，基本类型数据存在栈内存中，引用类型数据只是在栈内存存储了一个指向堆内存的指针，实际数据存放在堆内存中。 const并不是保证这个变量不可以改变，而是保证这个变量指向的占内存的值不可改变，所以使用const创建引用类型数据要小心</p> <h2 id="_2-变量提升与暂时性死区"><a href="#_2-变量提升与暂时性死区" class="header-anchor">#</a> 2. 变量提升与暂时性死区</h2> <p><strong>var 存在变量提升， let 和 const 不存在变量提升</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> name<span class="token operator">=</span><span class="token string">'jack'</span><span class="token punctuation">;</span>

<span class="token punctuation">{</span>
  name<span class="token operator">=</span><span class="token string">'bob'</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> name<span class="token punctuation">;</span>    <span class="token comment">//Uncaught ReferenceError: Cannot access 'name' before initialization</span>
<span class="token punctuation">}</span>
</code></pre></div><p>记住 ES6 中的一个特性，如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。因为JS清楚地感知到了 name 是用 let 声明在当前这个代码块内的，所以会给这个变量 name 加上了暂时性死区的限制，它就不往外探出头了。</p> <h2 id="_3-变量的结构赋值"><a href="#_3-变量的结构赋值" class="header-anchor">#</a> 3. 变量的结构赋值</h2> <p><a href="https://juejin.cn/post/6873482248625225741" target="_blank" rel="noopener noreferrer">参考链接<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="_4-箭头函数及其this问题"><a href="#_4-箭头函数及其this问题" class="header-anchor">#</a> 4. 箭头函数及其this问题</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//1.2一个参数（括号可以省略）</span>
<span class="token keyword">var</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token parameter">v</span> <span class="token operator">=&gt;</span> v<span class="token punctuation">;</span>
<span class="token comment">// 等同于</span>
<span class="token keyword">var</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> v<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token comment">// 等同于</span>
<span class="token keyword">var</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> <span class="token function-variable function">sum</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">num1<span class="token punctuation">,</span> num2</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> num1 <span class="token operator">+</span> num2<span class="token punctuation">;</span>
<span class="token comment">// 等同于</span>
<span class="token keyword">var</span> <span class="token function-variable function">sum</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">num1<span class="token punctuation">,</span> num2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> num1 <span class="token operator">+</span> num2<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'lihh'</span><span class="token punctuation">,</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">,</span>
    <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我叫'</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">'今年'</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
打印结果是<span class="token keyword">this</span>指向了Person
</code></pre></div><p>箭头函数使得表达更加简洁。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">isEven</span> <span class="token operator">=</span> <span class="token parameter">n</span> <span class="token operator">=&gt;</span> n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">square</span> <span class="token operator">=</span> <span class="token parameter">n</span> <span class="token operator">=&gt;</span> n <span class="token operator">*</span> n<span class="token punctuation">;</span>

</code></pre></div><ul><li>箭头函数没有自己的this，他是在定义函数的时候绑定的，而不是在执行过程中绑定的，它继承了定义函数的对象</li> <li>箭头函数的一个用处是简化回调函数。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 正常函数写法</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 箭头函数写法</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=&gt;</span> x <span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。
this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。</p> <h2 id="_5-symbol概念及其作用"><a href="#_5-symbol概念及其作用" class="header-anchor">#</a> 5. Symbol概念及其作用</h2> <p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。</p> <p>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p> <p>Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p> <ul><li><p>Symbol 的引入是为了防止对象属性名冲突</p></li> <li><p>Symbol 是一种新的原始数据类型</p></li> <li><p>Symbol 值是独一无二的</p></li> <li><p>symbols 作为对象的属性 symbols 有另一个很重要的用途，就是用作对象的 key。这儿有一个 symbols 作为对象 key 使用的例子：</p></li></ul> <ol><li>添加描述属性</li></ol> <p>const sym = Symbol('foo');</p> <p>sym.description // &quot;foo&quot;</p> <ol start="2"><li>作为属性名的 Symbol</li></ol> <p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p> <p>let mySymbol = Symbol();</p> <p>let a = {};</p> <p>a[mySymbol] = 'Hello!';</p> <ol start="3"><li>共享Symbol</li></ol> <p>有时，我们希望重新使用同一个 Symbol 值，Symbol.for()方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p> <p>let s1 = Symbol.for('foo');</p> <p>let s2 = Symbol.for('foo');</p> <p>s1 === s2 // true</p> <p>上面代码中，s1和s2都是 Symbol 值，但是它们都是由同样参数的Symbol.for方法生成的，所以实际上是同一个值。</p> <p>Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for(&quot;cat&quot;)30 次，每次都会返回同一个 Symbol 值，但是调用Symbol(&quot;cat&quot;)30 次，会返回 30 个不同的 Symbol 值。</p> <h2 id="_6-set和map数据结构"><a href="#_6-set和map数据结构" class="header-anchor">#</a> 6. Set和Map数据结构</h2> <h3 id="map"><a href="#map" class="header-anchor">#</a> MAP</h3> <p>作用：Map对象用于保存键值对，它的键可以为任意类型的数据，常用于建立数据的映射关系。</p> <p>Map 中的 key    key是字符串</p> <p>用法： Map()是一个构造函数，需要用new来实例化，Map()构造函数貌似只能接收一个二维数组的参数null和undefined（至少目前遇到的是这样），其他类型参数会报错</p> <ol><li>Map的key可以为任意类型的值；</li> <li>new一个Map就是新实例化了一个Map；</li> <li>对同一个key值进行多次赋值，后面的会覆盖前面的；</li> <li>未被set的Map关键字使用get方法会返回<code>undefined</code>;</li> <li>Map 的键是跟内存地址绑定的，引用类型数据需要指向同一个地址才是同一个键；</li> <li>原始数据类型，只要他们的值严格相等，Map 将其视为一个键；</li> <li>NaN不严格相等于自身，但 Map 将其视为同一个键；</li> <li>undefined和null是两个不同的键</li></ol> <p>set() get()  has()  delete() clear() size</p> <p>Map的遍历(迭代)
for...of  for (var [key, value] of myMap)
forEach()</p> <p>Map结构可以通过扩展运算符(...)转为数组   [...myMap]</p> <p>Map 的克隆</p> <p>Map 的合并
var myMap = new Map([...myMap1, ...myMap2]);</p> <h3 id="set结构"><a href="#set结构" class="header-anchor">#</a> Set结构</h3> <p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p> <p>-Set允许存储任何类型的唯一值，但Set()不能接收Object、Boolean和NaN，使用add()方法可添加任意类型值； -向 Set 加入值的时候，不会发生类型转换，所以123和&quot;123&quot;是两个不同的值； -Set 内部使用“===”来判断两个值是否相等，但是NaN是个特例 -引用类型得地址指向相同才是唯一值，Symbol得用变量存储才能被has()取到 -+0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复； -undefined 与 undefined 是恒等的，所以不重复； -Set 结构的键名就是键值</p> <p>Set()是一个构造函数，需要用new来实例化，Set()构造函数可以接收一个具有 iterable 接口的其他数据结构（如数组，Map和Set结构等数据），其他类型会报错</p> <ul><li>Set.prototype.add(value)：添加某个值，返回 Set 结构本身。</li> <li>Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li> <li>Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。</li> <li>Set.prototype.clear()：清除所有成员，没有返回值。</li></ul> <p><strong>for...of</strong></p> <p>Set结构原生提供三个遍历器生成函数： -Set.prototype.keys()：返回键名的遍历器。 -Set.prototype.values()：返回键值的遍历器。 -Set.prototype.entries()：返回所有成员的遍历器。</p> <p>Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法，因此可以省略values方法，直接用for...of循环遍历 Set。</p> <p><strong>forEach()</strong></p> <p>set.forEach((value, key) =&gt; console.log(key + ' : ' + value))</p> <p><strong>Set的应用场景</strong></p> <ul><li>数组去重</li> <li>字符串去重</li> <li>求数组并集</li> <li>求数组交集</li> <li>求数组差集</li></ul> <h2 id="_7-proxy"><a href="#_7-proxy" class="header-anchor">#</a> 7. Proxy</h2> <p>一个 Proxy 对象包装另一个对象并拦截诸如读取/写入属性和其他操作，可以选择自行处理它们，或者透明地允许该对象处理它们。</p> <p>对 proxy 的实例化需要两个参数, target 代表需要被代理的对象, handlers 代表对该代理对象的各种操作行为处理</p> <p>let proxy = new Proxy(target, handler)</p> <p>早期可以用 getter, setter, 但是每个代理属性都要编写对应的 getter, setter, 而且需要存在一个存储真实值的键, 否则会递归溢出</p> <h2 id="_8-reflect对象"><a href="#_8-reflect对象" class="header-anchor">#</a> 8. Reflect对象</h2> <p>Reflect 是一个内置对象，可简化的创建 Proxy。</p> <p>以前的内部方法，比如[[Get]]，[[Set]] 等等都只是规范，不能直接调用。</p> <p>Reflect 对象使调用这些内部方法成为可能。它的方法是内部方法的最小包装。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'John'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// John</span>
</code></pre></div><p>尤其是，Reflect 允许我们使用函数（Reflect.construct，Reflect.deleteProperty，……）执行操作（new，delete，……）。这是一个有趣的功能，但是这里还有一点很重要。</p> <p>对于每个可被 Proxy 捕获的内部方法，Reflect 都有一个对应的方法 Reflect，其名称和参数与 Proxy 钩子相同。</p> <h2 id="_9-promise-手撕promise-a-规范、promise-all、promise相关api和方法"><a href="#_9-promise-手撕promise-a-规范、promise-all、promise相关api和方法" class="header-anchor">#</a> 9. Promise（手撕Promise A+规范、Promise.all、Promise相关API和方法）</h2> <p>静态方法：Promise.resolve
Promise.reject
Promise.all
Promise.race</p> <p>Promise是异步编程的一种解决方案，比起传统的解决方案（回调函数和事件），它显得更加的强大和方便（具体请看下文）。从语法上来讲，Promise是一个对象，从它可以获取异步操作的消息。Promise对象提供统一的API，各种异步操作都可以用同样的方法进行处理。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在这里做一些逻辑处理</span>
    <span class="token comment">// 如果异步操作成功的时候，调用resolve</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'success'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 操作失败后我们就调用reject()</span>
        <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'fail'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

p1<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// success</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div><p>我们可以看到Promise是一个构造函数，用来生成Promise实例，它接收一个函数作为参数，这个函数有两个参数——resolve和reject（它们也是两个函数，已经由JavaScript引擎提供，不用自己部署）。
我们经常会在这个函数里处理一些逻辑，如果处理成功后我们会执行resolve（将状态从“未完成”转为“完成”），失败后执行reject（将状态从“未完成”转换为“失败”）。</p> <p><strong>三个状态</strong></p> <ul><li>pedding(未完成)</li> <li>resolved(完成)</li> <li>rejected(失败)</li></ul> <h2 id="_10-iterator和for-of-iterator遍历器的实现"><a href="#_10-iterator和for-of-iterator遍历器的实现" class="header-anchor">#</a> 10. Iterator和for...of（Iterator遍历器的实现）</h2> <p><strong>Symbol.iterator</strong></p> <p>在可被 for...of 迭代遍历的数据集合的原型链中都存在该属性为 key 的方法。</p> <p>还有一些特殊的数据类型，类似数组对象 TypedArray，比如：函数参数集合 arguments</p> <p>类似数组对象的定义：有 length 属性和若干索引属性对象。</p> <p>并不是所有类似数组对象都存在 Iterator 接口，可以使用 Array.from() 将其转为数组。</p> <p>遍历器(iterator)属性是一种接口，为各种数据结构提供一个统一的访问机制。不管何种数据结构，只要部署了 Iterator 接口，就能完成遍历操作 。</p> <p><strong>作用：</strong></p> <ul><li>为各种数据结构提供一个便捷的、统一的访问接口；</li> <li>使得数据结构的成员 item 按照次序排列；</li> <li>主要提供给 for...of 消费</li></ul> <p><strong>遍历过程：</strong></p> <ul><li>创建一个指针对象，指向当前数据结构起始位置。遍历器对象本质上就是一个指针对象。</li> <li>第一次调用指针对象的 next 方法，指针就指向第一个成员。</li> <li>第二次调用 next 方法，指针就指向第二个成员。</li> <li>......循环执行第三步，直到指针指向该数据结构结束位置。</li></ul> <p>next 方法返回的对象结构：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        value<span class="token operator">:</span> item<span class="token punctuation">,</span>    <span class="token comment">// 当前下标指向的位置成员</span>
        done<span class="token operator">:</span> Boolean<span class="token punctuation">,</span>  <span class="token comment">// 遍历是否结束，true 为结束</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> iter <span class="token operator">=</span> a<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行数组的 iterator 属性方法</span>

iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value: '1', done: false }</span>
iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value: '2', done: false }</span>
iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value: '3', done: false }</span>
iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value: undefined, done: true }</span>

</code></pre></div><h3 id="在什么情况下会调用-symbol-iterator-接口"><a href="#在什么情况下会调用-symbol-iterator-接口" class="header-anchor">#</a> 在什么情况下会调用 Symbol.iterator 接口</h3> <ol><li>对数组或者 Set 数据类型解构赋值时会默认触发；</li> <li>扩展运算符也会默认调用 Iterator 接口，可以利用该特性将部署了 Iterator 接口的对象使用扩展运算符转为数组；</li> <li>yield* 后面跟一个可遍历结构数据也会默认触发；</li> <li>所有接受数组为参数的方法都调用了遍历器接口</li></ol> <ul><li>Array.from</li> <li>for...of</li> <li>Promise.all</li> <li>Promise.race</li> <li>Map Set WeakMap WeakSet</li></ul> <p><strong>Symbol.iterator 就是为了给 for...of 循环提供一个统一的遍历接口，for...of 能遍历所有提供了 Symbol.iterator 接口的数据集合；for...of 也是为了让遍历更优雅，提升代码的可读性，毕竟 for...of 的写法比起 for 表达式更简洁。</strong></p> <h2 id="_11-循环语法比较及使用场景-for、foreach、for-in、for-of"><a href="#_11-循环语法比较及使用场景-for、foreach、for-in、for-of" class="header-anchor">#</a> 11. 循环语法比较及使用场景（for、forEach、for...in、for...of）</h2> <h3 id="for-in"><a href="#for-in" class="header-anchor">#</a> for...in：</h3> <p>var a = [1,2,3];</p> <p>for (var k in a) {}</p> <p>我们都知道，for...in 遍历返回的是键名，数组的键名应该是数字，但是 for...in 在遍历数组的时候却是返回的字符串；</p> <p>for...in 不仅遍历数字键名，还会遍历手动添加的其它键，甚至包括原型链上的键；</p> <p>某些情况下，for...in 循环会以任意顺序遍历键名；</p> <h3 id="foreach"><a href="#foreach" class="header-anchor">#</a> forEach：</h3> <p>a.forEach(function(item){}</p> <p>这种循环方式 break 命令无效，无法跳出循环，只能利用 return 跳出当次循环；</p> <h3 id="for"><a href="#for" class="header-anchor">#</a> for：</h3> <p>这种方式都知道的，最基础的循环，for (var i = 0; i &lt; 10; i++) { } 一眼过去就知道用这种方式循环还是比较麻烦的；</p> <h3 id="for-of"><a href="#for-of" class="header-anchor">#</a> for...of：</h3> <ul><li>和 for...in 一样的简洁语法，但是没有对应的缺点；</li> <li>与 forEach 不同，break continue 和 return 可以配合使用；</li> <li>提供遍历所有数据结构统一的接口；</li></ul> <h2 id="_12-generator及其异步方面的应用"><a href="#_12-generator及其异步方面的应用" class="header-anchor">#</a> 12. Generator及其异步方面的应用</h2> <p>当我们写一个函数 在function后面或者函数名字前面加上一个* 调用这个函数返回的就是Generator 而这个函数称为Generator函数</p> <p>gen函数体内，我们用同步代码的写法，实现了异步操作。可以看到，用gererator来执行异步操作，在代码可读性、可扩展性上面，是很有优势的。</p> <h2 id="_13-async函数"><a href="#_13-async函数" class="header-anchor">#</a> 13. async函数</h2> <p>我们知道，调用Generator函数不会立即执行，而是返回遍历器对象。疲于手动执行遍历器对象，因此就有了thunk(thunkify)函数结合run函数来实现自动流程管理。或者，使用co模块来实现自动流程管理，使Generator函数的使用更加方便。</p> <p>而async函数ES2017标准引入的语法，是Generator函数的语法糖，因此其相对于Generator函数，具有以下基本特点。</p> <p><strong>内置执行器：</strong> 使用async函数可以像使用普通函数一样，直接调用即可执行。不用像Generator函数一样使用co模块来实现流程控制。</p> <p><strong>语义化更强</strong>:async关键字表示是一个异步的函数，await表示需要等待执行。相对于yield表达式，语义化更强。</p> <p><strong>返回值是Promise</strong>： async函数返回值是Promise对象，这比Generator函数的返回值是Iterator对象方便多了，可以使用then方法来指定下一步的操作。</p> <p>使用async关键字表明函数是一个async函数，内部使用await关键字表明需要等待异步任务结束后才继续往下执行。</p> <ol><li>async函数是基于Generator函数实现的，是Generator函数的语法糖。其内置执行器，调用后返回Promise对象，因此可以像普通韩式一样使用。</li> <li>async函数内部抛出错误或者await关键字后面的表达式抛出错误，会使async函数返回的Promise对象从pending状态变为reject状态，从而可以被catch方法捕获错误。而且，Promise对象的状态一旦改变就不会再变，之后的异步任务就不会执行了。</li> <li>await关键字后面的表达式可以是Promise对象，也可以是其他数据类型。如果是其他数据类型，则会通过Promise.resolve将其转换为Promise对象</li> <li>async函数内部如果有多个await关键字，其后的异步任务会继发执行。如果每一个异步任务不相互依赖，则可以使用Promise.all让其并发执行，这样可以在同样的时间里完成多个异步任务，提高函数执行效率。</li> <li>对于async内部抛出的错误，可以使用try...catch来捕获异常。虽然try...catch只能用于捕获同步任务，但是await关键字可以使得异步任务同步化,因此可以结合try...catch和await关键字捕获异步任务。</li></ol> <h2 id="_14-几种异步方式的比较-回调、settimeout、promise、generator、async"><a href="#_14-几种异步方式的比较-回调、settimeout、promise、generator、async" class="header-anchor">#</a> 14. 几种异步方式的比较（回调、setTimeout、Promise、Generator、async）</h2> <p><strong>回调</strong></p> <p><strong>setTimeout</strong></p> <p><strong>Promise</strong></p> <p><strong>Generator</strong></p> <p><strong>async</strong></p> <h2 id="_15-class基本语法及继承"><a href="#_15-class基本语法及继承" class="header-anchor">#</a> 15. class基本语法及继承</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
  <span class="token comment">// class 方法</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
  <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
  <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
  <span class="token function">method3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>继承</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">ColorPoint</span> <span class="token keyword">extends</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> color</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>父类的静态方法也会被子类继承</p> <p>关键字——super</p> <p>super代表的是父类构造函数，但是返回的是子类的实例。比如A是B的父类，那么super的功能相当于A.prototype.constructor.call(this)。</p> <p>super的使用方式：1、当函数使用。2、当对象使用</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 当函数使用</span>
<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 当对象使用</span>
<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token function">p</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">p</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


</code></pre></div><h2 id="_16-模块加载方案比较-commonjs和es6的module"><a href="#_16-模块加载方案比较-commonjs和es6的module" class="header-anchor">#</a> 16. 模块加载方案比较（CommonJS和ES6的Module）</h2> <p>CommonJS导出的是对象，内部要导出的变量在导出的那一刻就已经赋值给对象的属性了，也就有了“CommonJS输出的是值的拷贝”这种说法，后面再在模块里修改变量，其他模块是感觉不到的，因为已经没有关系了。但是对象还是会影响，因为对象拷贝的只是对象的引用。</p> <p>也是因为CommonJS导出的是对象，在编译阶段不会读取对象的内容，并不清楚对象内部都导出了哪些变量、这些变量是不是从别的文件导入进来的。只有等到代码运行时才能访问对象的属性，确定依赖关系。因此才说CommonJS的模块是动态加载的。</p> <p>而对ES6 Module来说，由于内部对每个变量都定义了getter，因此其他模块导入后访问变量时触发getter，返回模块里的同名变量，如果变量值发生变化，则外边的引用也会变化。</p> <p>但是export default没有走getter的形式，也是直接赋值，所以输出的也是一份拷贝。</p> <p>ES6 Module导出的不是一个对象，导出的是一个个接口，因此在编译时就能确定模块之间的依赖关系，所以才说ES6 Module是静态加载的。Tree Shaking就是根据这个特性在编译阶段摇掉无用模块的。</p> <p>ES6 Module还提供了一个import()方法动态加载模块，返回一个Promise。</p> <h2 id="_17-es6模块加载与commonjs加载的原理"><a href="#_17-es6模块加载与commonjs加载的原理" class="header-anchor">#</a> 17. ES6模块加载与CommonJS加载的原理</h2></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/JavaScript.html" class="prev">
        JavaScript
      </a></span> <span class="next"><a href="/blog/HTML-CSS.html">
        HTML-CSS
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.03c3e821.js" defer></script><script src="/assets/js/2.fef91045.js" defer></script><script src="/assets/js/13.46aa809f.js" defer></script>
  </body>
</html>
