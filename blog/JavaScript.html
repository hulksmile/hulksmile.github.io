<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JavaScript | hulksmile</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.35bcedcf.css" as="style"><link rel="preload" href="/assets/js/app.03c3e821.js" as="script"><link rel="preload" href="/assets/js/2.fef91045.js" as="script"><link rel="preload" href="/assets/js/10.38705d39.js" as="script"><link rel="prefetch" href="/assets/js/11.4206f2b3.js"><link rel="prefetch" href="/assets/js/12.03409474.js"><link rel="prefetch" href="/assets/js/13.46aa809f.js"><link rel="prefetch" href="/assets/js/14.282f939a.js"><link rel="prefetch" href="/assets/js/15.30e7d426.js"><link rel="prefetch" href="/assets/js/16.bb6e8dc5.js"><link rel="prefetch" href="/assets/js/3.5e04ea21.js"><link rel="prefetch" href="/assets/js/4.09ee8a39.js"><link rel="prefetch" href="/assets/js/5.30fca801.js"><link rel="prefetch" href="/assets/js/6.498ab014.js"><link rel="prefetch" href="/assets/js/7.91f7f8c5.js"><link rel="prefetch" href="/assets/js/8.025f27e6.js"><link rel="prefetch" href="/assets/js/9.291fbd70.js">
    <link rel="stylesheet" href="/assets/css/0.styles.35bcedcf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">hulksmile</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/JavaScript.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  JavaScript
</a></div> <a href="https://github.com/hulksmile/hulksmile.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    My GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/JavaScript.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  JavaScript
</a></div> <a href="https://github.com/hulksmile/hulksmile.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    My GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/" aria-current="page" class="sidebar-link">首页</a></li><li><a href="/blog/JavaScript.html" aria-current="page" class="active sidebar-link">JavaScript</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_1-原始值和引用值类型及区别" class="sidebar-link">1.原始值和引用值类型及区别</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_2-判断数据类型typeof、instanceof、object-prototype-tostring-call-、constructor" class="sidebar-link">2. 判断数据类型typeof、instanceof、Object.prototype.toString.call()、constructor</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_3-类数组与数组的区别与转换" class="sidebar-link">3. 类数组与数组的区别与转换</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_8-闭包及其作用" class="sidebar-link">8. 闭包及其作用</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_9-原型和原型链" class="sidebar-link">9. 原型和原型链</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_10-prototype与-proto-的关系与区别" class="sidebar-link">10. prototype与_proto_的关系与区别</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_11-继承的实现方式及比较" class="sidebar-link">11. 继承的实现方式及比较</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_12-深拷贝与浅拷贝" class="sidebar-link">12. 深拷贝与浅拷贝</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_13-防抖和节流" class="sidebar-link">13. 防抖和节流</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_14-作用域和作用域链、执行期上下文" class="sidebar-link">14. 作用域和作用域链、执行期上下文</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_15-dom常见的操作方式" class="sidebar-link">15. DOM常见的操作方式</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_16-array-sort-方法与实现机制" class="sidebar-link">16. Array.sort()方法与实现机制</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_17-ajax的请求过程" class="sidebar-link">17. Ajax的请求过程</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_18-js的垃圾回收机制" class="sidebar-link">18. JS的垃圾回收机制</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_19-js中的string、array和math方法" class="sidebar-link">19. JS中的String、Array和Math方法</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_20-addeventlistener和onclick-的区别" class="sidebar-link">20. addEventListener和onClick()的区别</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_21-new和object-create的区别" class="sidebar-link">21. new和Object.create的区别</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_22-dom的location对象" class="sidebar-link">22. DOM的location对象</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_23-浏览器从输入url到页面渲染的整个流程-涉及到计算机网络数据传输过程、浏览器解析渲染过程" class="sidebar-link">23. 浏览器从输入URL到页面渲染的整个流程（涉及到计算机网络数据传输过程、浏览器解析渲染过程）</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_24-跨域、同源策略及跨域实现方式和原理" class="sidebar-link">24. 跨域、同源策略及跨域实现方式和原理</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_25-浏览器的回流-reflow-和重绘-repaints" class="sidebar-link">25. 浏览器的回流（Reflow）和重绘（Repaints）</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_26-javascript中的arguments" class="sidebar-link">26. JavaScript中的arguments</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_27-eventloop事件循环" class="sidebar-link">27. EventLoop事件循环</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_28-宏任务与微任务" class="sidebar-link">28. 宏任务与微任务</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_29-bom属性对象方法-浏览器对象模型" class="sidebar-link">29. BOM属性对象方法  浏览器对象模型</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_30-函数柯里化及其通用封装" class="sidebar-link">30. 函数柯里化及其通用封装</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_31-js的map-和reduce-方法" class="sidebar-link">31. JS的map()和reduce()方法</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_32-和-的区别" class="sidebar-link">32. “==”和“===”的区别</a></li><li class="sidebar-sub-header"><a href="/blog/JavaScript.html#_33-settimeout用作倒计时为何会产生误差" class="sidebar-link">33. setTimeout用作倒计时为何会产生误差？</a></li></ul></li><li><a href="/blog/es6.html" class="sidebar-link">es6</a></li><li><a href="/blog/HTML-CSS.html" class="sidebar-link">HTML-CSS</a></li><li><a href="/blog/HTTP与计算机网络.html" class="sidebar-link">HTTP与计算机网络</a></li><li><a href="/blog/前端工程化.html" class="sidebar-link">前端工程化</a></li><li><a href="/blog/NodeJS.html" class="sidebar-link">NodeJS</a></li><li><a href="/blog/需要会手撕的代码部分.html" class="sidebar-link">需要会手撕的代码部分</a></li><li><a href="/blog/VUE.html" class="sidebar-link">VUE</a></li><li><a href="/blog/计算机基础.html" class="sidebar-link">计算机基础</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="javascript"><a href="#javascript" class="header-anchor">#</a> JavaScript</h1> <h2 id="_1-原始值和引用值类型及区别"><a href="#_1-原始值和引用值类型及区别" class="header-anchor">#</a> 1.原始值和引用值类型及区别</h2> <p><a href="https://blog.csdn.net/weixin_42721322/article/details/106333987" target="_blank" rel="noopener noreferrer">参考链接<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li><strong>原始值（简单数据类型）</strong>：存储在栈中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。
包含五种简单数据类型：undefined、null、boolean、number 和 string ；可以通过typeof 运算符来判断一个值是否在某种类型的范围内，如果它是原始类型，还可以判断它表示哪种原始类型。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>var num1 = 100;
var num2;
num2 = num1;
num1=10;
console.log(num1, num2);// 10, 100
</code></pre></div><ul><li>引用值（复杂数据类型）：存储在堆中的对象，放在变量的栈空间中的值是该对象存储在堆中的地址，也就是说，存储在变量处的值是一个指针（内存地址），指向存储对象的堆内存中。
包含：Object、function、array等。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token punctuation">{</span>
            name<span class="token operator">:</span><span class="token string">'xiaoming'</span>
        <span class="token punctuation">}</span>
  <span class="token keyword">var</span> num2<span class="token punctuation">;</span>
  num2 <span class="token operator">=</span> num1<span class="token punctuation">;</span>
  num1<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">'xiaobai'</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出结果相同</span>
</code></pre></div><ul><li>但如果你想要复制赋值，另外一个值不会随他的改变而改变，则必须要重新分配对象，此时，该值的原指针（内存地址）改变，则另外一个值不会随他的改变而改变。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token punctuation">{</span>
            name<span class="token operator">:</span> <span class="token string">'xiaoming'</span>
        <span class="token punctuation">}</span>
<span class="token keyword">var</span> num2 <span class="token operator">=</span>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>num1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//num2 = num1;</span>
num2<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'xiaobai'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//{name: &quot;xiaoming&quot;} {name: &quot;xiaobai&quot;}输出结果不同</span>
</code></pre></div><h2 id="_2-判断数据类型typeof、instanceof、object-prototype-tostring-call-、constructor"><a href="#_2-判断数据类型typeof、instanceof、object-prototype-tostring-call-、constructor" class="header-anchor">#</a> 2. 判断数据类型typeof、instanceof、Object.prototype.toString.call()、constructor</h2> <p>JS的数据类型: 基础数据类型和复杂数据类型(引用数据类型)</p> <ul><li>基础数据类型: number string undefined null boolean symbol</li> <li>引用数据类型: object</li></ul> <h3 id="typeof"><a href="#typeof" class="header-anchor">#</a> typeof</h3> <p>null 有属于自己的类型 Null，而不属于Object类型，typeof 之所以会判定为 Object 类型，是因为JavaScript 数据类型在底层都是以二进制的形式表示的，二进制的前三位为 0 会被 typeof 判断为对象类型，而 null 的二进制位恰好都是 0 ，因此，null 被误判断为 Object 类型。</p> <p>优点：能快速检查undefined,string,number,boolean类型</p> <p>缺点：当类型为object,null,array时都会返回object,所以不能区分这三类</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//string</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　<span class="token comment">//number</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　<span class="token comment">//boolean</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　<span class="token comment">//object</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　<span class="token comment">//undefined</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　<span class="token comment">//object</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　<span class="token comment">//function</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　<span class="token comment">//object</span>
</code></pre></div><h3 id="instanceof"><a href="#instanceof" class="header-anchor">#</a> instanceof</h3> <p>instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。简单来说就是 instanceof 是用来判断 A 是否为 B 的实例，表达式为
A (object) instanceof B (constructor)
如果 A 是 B 的实例，则返回 true,否则返回 false。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span>
</code></pre></div><p>优点：能检测array,function,object类型</p> <p>缺点:检测不了字面量定义的number,boolean,string</p> <h3 id="object-prototype-tostring-call"><a href="#object-prototype-tostring-call" class="header-anchor">#</a> Object.prototype.toString.call()</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> “<span class="token punctuation">[</span>object Number<span class="token punctuation">]</span>”
obj<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>“<span class="token number">1</span>”<span class="token punctuation">)</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> “<span class="token punctuation">[</span>object String<span class="token punctuation">]</span>”
obj<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> “<span class="token punctuation">[</span>object Boolean<span class="token punctuation">]</span>”
</code></pre></div><p>除了null/undefined，大部分数据类型所属类的原型上，都有toString方法；但是所有的toString方法都是转换为字符串的只有Object原型上的toString方法是检测数据类型的。
优点：结果准确</p> <h3 id="constructor"><a href="#constructor" class="header-anchor">#</a> constructor</h3> <p>和instanceof类似，都是临时用做数据类型检测使用的，constructor原型可以重构，导致结构不准确。
相对于instanceof，constructor可以检测原始值类型，但是只会基于原型链上的直属类检测。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Array <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> <span class="token boolean">true</span>
arr<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Object <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> <span class="token boolean">false</span>
ps：因为arr<span class="token punctuation">.</span>constructor直接指向的是Array
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">Fn</span><span class="token punctuation">.</span>prototype<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> f<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>constructor<span class="token operator">===</span>Fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>constructor<span class="token operator">===</span>Array<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我声明了一个构造函数，并且把他的原型指向了Array的原型，所以这种情况下，constructor也显得力不从心了。</p> <h2 id="_3-类数组与数组的区别与转换"><a href="#_3-类数组与数组的区别与转换" class="header-anchor">#</a> 3. 类数组与数组的区别与转换</h2> <ul><li><p>相同点：都可用下标访问每个元素，都有length属性。</p></li> <li><p>不同点：数组对象的类型是Array,类数组对象的类型是object，也就是说类数组原型是Object;类数组不具有数组所具有的方法，数组遍历可以用 for in和for循环,类数组只能用for循环遍历。</p></li></ul> <p>常见的类数组有: 函数的参数 arguments, DOM 对象列表(比如通过 document.querySelectorAll 得到的列表), jQuery 对象 (比如 $(“div”)).</p> <h3 id="转换方法"><a href="#转换方法" class="header-anchor">#</a> 转换方法：</h3> <h4 id="数组转变成类数组"><a href="#数组转变成类数组" class="header-anchor">#</a> 数组转变成类数组:</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span> <span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
</code></pre></div><p>输出为原型为Object 的一个对象</p> <h4 id="类数组转变为数组"><a href="#类数组转变为数组" class="header-anchor">#</a> 类数组转变为数组：</h4> <ul><li>方法一:Array.prototype.slice.call(arrayLike, start);</li> <li>方法二: Array.from(arrayLike);</li></ul> <h3 id="_4-数组的常见api"><a href="#_4-数组的常见api" class="header-anchor">#</a> 4. 数组的常见API</h3> <h4 id="不改变原数组"><a href="#不改变原数组" class="header-anchor">#</a> 不改变原数组：</h4> <ul><li>将数组转化为字符串（String）</li> <li>把数组中的所有元素放入一个字符串（join）</li> <li>数组拼接（concat）</li> <li>数组选取，获取子数组（slice 含头不含尾）</li> <li>返回某个指定的字符串值在字符串中首次出现的位置（indexOf）</li></ul> <h4 id="改变原数组"><a href="#改变原数组" class="header-anchor">#</a> 改变原数组</h4> <ul><li>从数组中添加/删除项目，然后返回被删除的项目（splice(i,n,jia,jia)从第i个开始的n个元素）</li> <li>反转数组元素（reverse）</li> <li>对数组的元素进行排序（sort）</li> <li>向数组的末尾添加一个或多个元素，并返回新的长度（push）</li> <li>删除并返回数组的最后一个元素（pop）</li> <li>用于把数组的第一个元素从其中删除，并返回第一个元素的值（shift）</li> <li>向数组的开头添加一个或更多元素，并返回新的长度（unshift）</li></ul> <h4 id="迭代方法-以下方法都不会修改数组中包含的值"><a href="#迭代方法-以下方法都不会修改数组中包含的值" class="header-anchor">#</a> 迭代方法（以下方法都不会修改数组中包含的值）：</h4> <ul><li>every():对数组中的每一项运行给定的函数，如果该函数对每一项都返回true，则返回true。</li> <li>filter():对数组中的每一项运行给定的函数，返回该函数会返回true的项组成的数组。</li> <li>forEach():对数组中的每一项运行给定的函数。这个方法没有返回值。</li> <li>map():对数组中的每一项运行给定的函数，返回每次函数调用的结果组成的数组。</li> <li>some():对数组中的每一项运行给定的函数，如果该函数对任一项返回true，则返回true。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> numbers<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> everyResult<span class="token operator">=</span>numbers<span class="token punctuation">.</span><span class="token function">every</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span>index<span class="token punctuation">,</span>array</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token punctuation">(</span>item<span class="token operator">&gt;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>everyResult<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span>
</code></pre></div><h3 id="_5-bind、call、apply的区别"><a href="#_5-bind、call、apply的区别" class="header-anchor">#</a> 5. bind、call、apply的区别</h3> <p>三者都是用于改变函数体内this的指向，但是bind与apply和call的最大的区别是：bind不会立即调用，而是返回一个新函数，称为绑定函数，其内的this指向为创建它时传入bind的第一个参数，而传入bind的第二个及以后的参数作为原函数的参数来调用原函数。</p> <p>apply和call都是为了改变某个函数运行时的上下文而存在的（就是为了改变函数内部this的指向）；apply和call的调用返回函数执行结果；</p> <p>如果使用apply或call方法，那么this指向他们的第一个参数，apply的第二个参数是一个参数数组，call的第二个及其以后的参数都是数组里面的元素，就是说要全部列举出来；</p> <h4 id="区别总结"><a href="#区别总结" class="header-anchor">#</a> 区别总结：</h4> <ul><li>当我们使用一个函数需要改变this指向的时候才会用到call,apply,bind</li> <li>如果你要传递的参数不多，则可以使用fn.call(thisObj, arg1, arg2 ...)</li> <li>如果你要传递的参数很多，则可以用数组将参数整理好调用fn.apply(thisObj, [arg1, arg2 ...])</li> <li>如果你想生成一个新的函数长期绑定某个函数给某个对象使用，则可以使用</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> testObj <span class="token operator">=</span> <span class="token function">test</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">testObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//true</span>

<span class="token keyword">var</span> objTest <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token string">&quot;作者&quot;</span><span class="token operator">:</span> <span class="token string">&quot;chengbo&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">/**
 * 预期返回false, 但是testObj是个绑定函数，所以不能改变其this指向
 */</span>
<span class="token function">testObj</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>objTest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
<span class="token function">testObj</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>objTest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>

</code></pre></div><h3 id="_6-new的原理"><a href="#_6-new的原理" class="header-anchor">#</a> 6. new的原理</h3> <p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例</p> <p>访问到构造函数里的属性
访问到原型中的属性</p> <p>没有return语句
从构造函数直观看，最后是没有 return语句的，但我们从返回结果也可以看出构造函数时默认情况会返回一个新对象</p> <h3 id="new原理"><a href="#new原理" class="header-anchor">#</a> new原理</h3> <p>mdn上把内部操作大概分为4步：</p> <ol><li>创建一个空的简单JavaScript对象（即{ } ）；</li> <li>链接该对象（即设置该对象的构造函数）到另一个对象 ；(因此this就指向了这个新对象)</li> <li>执行构造函数中的代码（为这个新对象添加属性）；</li> <li>如果该函数没有返回对象，则返回this。</li></ol> <h3 id="_7-如何正确判断this"><a href="#_7-如何正确判断this" class="header-anchor">#</a> 7. 如何正确判断this？</h3> <ul><li>this在调用的时候才会指向</li> <li>new可以改变this的指向,new中有返回值，如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>user <span class="token operator">=</span> <span class="token string">&quot;追梦子&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//追梦子</span>
</code></pre></div><h2 id="_8-闭包及其作用"><a href="#_8-闭包及其作用" class="header-anchor">#</a> 8. 闭包及其作用</h2> <p><strong>如果一个函数用到了它作用域外面的变量，那么这个变量和这个函数之间的环境就叫闭包。</strong></p> <p><strong>闭包的用途有些什么？</strong></p> <ol><li><strong>模仿块级作用域</strong>
所谓块级作用域就是指在循环中定义的变量，一旦循环结束，变量也随之销毁，它的作用范围只在这一小块。而在JavaScript中没有这样的块级作用域，由于JavaScript不会告诉你变量是否已经被声明，所以容易造成命名冲突，如果在全局环境定义的变量，就会污染全局环境，因此可以利用闭包的特性来模仿块级作用域。</li> <li><strong>储存变量</strong>
闭包的另一个特点是可以保存外部函数的变量，内部函数保留了对外部函数的活动变量的引用，所以变量不会被释放。</li> <li><strong>封装私有变量</strong>
我们可以把函数当作一个范围，函数内部的变量就是私有变量，在外部无法引用，但是我们可以通过闭包的特点来访问私有变量。</li></ol> <h2 id="_9-原型和原型链"><a href="#_9-原型和原型链" class="header-anchor">#</a> 9. 原型和原型链</h2> <h3 id="prototype"><a href="#prototype" class="header-anchor">#</a> prototype</h3> <p>在JavaScript中，每个函数都有一个prototype属性，这个属性指向函数的原型对象。</p> <p><strong>原型</strong>的概念：每一个javascript对象(除null外)创建的时候，就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中“继承”属性。
<img src="/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A4%BA%E4%BE%8B%E5%8E%9F%E5%9E%8B%E5%85%B3%E7%B3%BB.png" alt="构造函数与示例原型关系"></p> <p><strong>实例对象的原型中会有公共的方法，每个实例都可以访问到，这样无需再重复实现，也就是继承。所以JavaScript中的继承，不是通过复制而来的，而是通过原型继承的，而访问的过程，就是所谓的“原型链”了。</strong></p> <h3 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h3> <p>每个实例对象（ object ）都有一个私有属性（可称之为__proto__ ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象(为__proto__ ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。</p> <h3 id="proto-原理"><a href="#proto-原理" class="header-anchor">#</a> __proto__原理</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p>这是每个对象(除null外)都会有的属性，叫做__proto__，这个属性会指向该对象的原型。
<img src="/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A4%BA%E4%BE%8B%E5%8E%9F%E5%9E%8B%E5%85%B3%E7%B3%BB2.png" alt="构造函数与示例原型关系2">
绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.<strong>proto</strong> 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p> <h2 id="_10-prototype与-proto-的关系与区别"><a href="#_10-prototype与-proto-的关系与区别" class="header-anchor">#</a> 10. prototype与__proto__的关系与区别</h2> <p>要注意区分__proto__和prototype：</p> <ul><li>__proto__是实例对象的私有属性，指向它的构造函数的prototype属性</li> <li>prototype是构造函数的属性，在调用构造函数创建实例对象时，实例对象通过__proto__和prototype相关联。同样的，prototype对象中会有__proto__，指向它自己的原型，这样一层层链接，直到指向null，形成原型链</li> <li>构造函数都是Function的实例</li> <li>函数默认有prototype属性，是定义公共方法的地方；prototype中有constructor属性，是指向函数本身。</li></ul> <h2 id="_11-继承的实现方式及比较"><a href="#_11-继承的实现方式及比较" class="header-anchor">#</a> 11. 继承的实现方式及比较</h2> <ul><li>原型继承, 将子类的原型指向了父类的实例, 这样子类就可以通过__proto__摸到父类的实例属性, 再由父类的实例的__proto__摸到其构造函数的原型对象</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
c<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">p</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>call继承, 这样父类改变了子类的实例, 不过call是Function上的方法</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">p</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>冒充对象继承, 循环遍历父类实例, 然后将父类实例的私有方法全部拿来给子类实例</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">p</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">in</span> p1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>混合继承, 将 call 继承和原型继承集合在一起</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">p</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
c<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">p</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> c<span class="token punctuation">;</span>
</code></pre></div><ul><li>中间件继承, 子类可以继承到父类的公有方法当做自己的公有方法</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
c<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> p<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
</code></pre></div><ul><li>寄生组合继承</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">p</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//继承实例属性</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">inheritPrototype</span><span class="token punctuation">(</span><span class="token parameter">sub<span class="token punctuation">,</span> sup</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>sup<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//继承原型链</span>
  prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> sub<span class="token punctuation">;</span>
  sub<span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">inheritPrototype</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>经典继承</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  c<span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> c1 <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//这样就继承o了</span>
</code></pre></div><h3 id="继承方法比较"><a href="#继承方法比较" class="header-anchor">#</a> 继承方法比较</h3> <ul><li>原型继承, 不同子类实例会共享同一对象, 如果修改属性其他实例获得的也是修改的, 并且创建子类实例的时候不能向超类构造函数传递参数</li> <li>组合继承, 每次都会调用两次超类的构造函数, 并且不同子类实例共享同一对象</li></ul> <p>完美的是寄生继承, 子类都有各自的实例, 不会互相影响, 且共享了父类的方法</p> <h2 id="_12-深拷贝与浅拷贝"><a href="#_12-深拷贝与浅拷贝" class="header-anchor">#</a> 12. 深拷贝与浅拷贝</h2> <p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。</p> <p>但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</p> <h2 id="_13-防抖和节流"><a href="#_13-防抖和节流" class="header-anchor">#</a> 13. 防抖和节流</h2> <ul><li><p>防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。</p></li> <li><p>节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。</p></li></ul> <h3 id="区别"><a href="#区别" class="header-anchor">#</a> 区别</h3> <p>函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。</p> <h2 id="_14-作用域和作用域链、执行期上下文"><a href="#_14-作用域和作用域链、执行期上下文" class="header-anchor">#</a> 14. 作用域和作用域链、执行期上下文</h2> <h3 id="作用域-scope"><a href="#作用域-scope" class="header-anchor">#</a> 作用域(Scope)</h3> <p>作用域概念是理解JavaScript的关键所在，不仅仅从性能角度，还包括从功能角度。作用域就是变量和函数的可访问范围，控制着变量和函数的可见性与生命周期，换句话说，作用域决定了代码区块中变量和其他资源的可见性。在JavaScript中变量的作用域有全局作用域和局部作用域。JavaScript采用词法作用域(lexical scoping)，也就是静态作用域。</p> <ul><li><p>词法作用域：词法作用域是指在词法分析阶段就确定了，不会改变。变量的作用域是在定义时决定而不是执行时决定，也就是说词法作用域取决于源码，通过静态分析就能确定，因此词法作用域也叫做静态作用域。</p></li> <li><p>动态作用域：动态作用域是在运行时根据程序的流程信息来动态确定的，而不是在写代码时进行静态确定的。 动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们在何处调用。</p></li></ul> <h4 id="全局作用域、局部作用域和块级作用域"><a href="#全局作用域、局部作用域和块级作用域" class="header-anchor">#</a> 全局作用域、局部作用域和块级作用域</h4> <p>在ECMAScript 5（包括ECMAScript 5）之前的版本中，作用域只有全局作用域和局部作用域，不存在块级作用域；ECMAScript 6引入了let和const关键字，利用let和const可以形成块级作用域。</p> <ol><li>全局作用域</li></ol> <p>在代码中任何地方都能访问到的对象拥有全局作用域。全局作用域的变量是全局对象的属性，不论在什么函数中都可以直接访问，而不需要通过全局对象，但加上全局对象，可以提供搜索效率。</p> <p>a、没有用var声明的变量（除去函数的参数）都具有全局作用域，成为全局变量，所以声明局部变量必须要用var。</p> <p>b、window的所有属性都具有全局作用域</p> <p>c、最外层函数体外声明的变量也具有全局作用域</p> <ol start="2"><li>局部作用域</li></ol> <p>局部变量的优先级高于全局变量。</p> <p>a、函数体内用var声明的变量具有局部作用域，成为局部变量</p> <p>b、函数的参数也具有局部作用域</p> <ol start="3"><li>块级作用域</li></ol> <p>使用let和const关键字声明的变量，会在形成块级作用域。</p> <h3 id="上下文-context"><a href="#上下文-context" class="header-anchor">#</a> 上下文(context)</h3> <p>许多开发人员经常混淆作用域(scope)和上下文(context)，很多误解为它们是相同的概念。但事实并非如此。作用域(scope)我们上面已经讨论过了，而上下文(context)是用来指定代码某些特定部分中this的值。作用域(scope) 是指变量的可访问性，上下文(context)是指this在同一作用域内的值。我们也可以使用call()、apply()、bind()、箭头函数等改变上下文。在浏览器中在全局作用域(scope)中上下文中始终是Window对象。在Node.js中在全局作用域(scope)中上下文中始终是Global 对象。</p> <p>上下文始终坚持一个原理：this 永远指向最后调用它的那个对象，上例中调用a函数的是window，所以a函数中的this指向window对象。关于this以及改变this的指向，可以参考this、apply、call、bind</p> <h3 id="作用域链-scope-chain"><a href="#作用域链-scope-chain" class="header-anchor">#</a> 作用域链(Scope Chain)</h3> <p>JavaScript 中每个函数都都表示为一个函数对象（函数实例），函数对象有一个仅供 JavaScript 引擎使用的[[scope]] 属性。通过语法分析和预解析，将[[scope]] 属性指向函数定义时作用域中的所有对象集合。这个集合被称为函数的作用域链（scope chain），包含函数定义时作用域中所有可访问的数据。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">num1<span class="token punctuation">,</span> num2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> sum <span class="token operator">=</span> num1 <span class="token operator">+</span> num2<span class="token punctuation">;</span>
  <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当定义 add 函数后，其作用域链就创建了。函数所在的全局作用域的全局对象被放置到 add 函数作用域链（[[scope]] 属性）中。我们可以从下图中看到作用域链的第一个对象保存的是全局对象，全局对象中保存了诸如 this , window , document 以及全局对象中的 add 函数，也就是他自己。这也就是我们可以在全局作用域下的函数中访问 window(this)，访问全局变量，访问函数自身的原因。全局上下文中的变量对象(Variable object，VO)就是全局对象。</p> <h3 id="执行期上下文-execution-context"><a href="#执行期上下文-execution-context" class="header-anchor">#</a> 执行期上下文(Execution Context)</h3> <p>执行具体的某个函数时，JS引擎在执行每个函数实例时，都会创建一个执行期上下文（Execution Context）和激活对象（active Object）（它们属于宿主对象，与函数实例执行的生命周期保持一致，也就是函数执行完成，这些对象也就被销毁了，闭包例外。）</p> <p>执行该函数创建一个内部对象，称为 Execution Context（执行期上下文）。执行期上下文定义了一个函数正在执行时的作用域环境。特别注意，执行期上下文和我们平常说的上下文不同，执行期上下文指的是作用域。平常说的上下文是this的取值指向。执行期上下文和函数创建时的作用域链对象 [[scope]] 区分，这是两个不同的作用域链对象。分开的原因很简单，函数定义时的作用域链对象 [[scope]] 是固定的，而 执行期上下文 会根据不同的运行时环境变化。而且该函数每执行一次，都会创建单独的 执行期上下文，因此对同一函数调用多次，会导致创建多个执行期上下文。一旦函数执行完成，执行期上下文将被销毁。</p> <h2 id="_15-dom常见的操作方式"><a href="#_15-dom常见的操作方式" class="header-anchor">#</a> 15. DOM常见的操作方式</h2> <h3 id="_1-访问-获取节点"><a href="#_1-访问-获取节点" class="header-anchor">#</a> 1.访问/获取节点</h3> <p>document.getElementById(id);　　　　　　　　 　　//返回对拥有指定id的第一个对象进行访问</p> <p>document.getElementsByName(name);　　　　　　//返回带有指定名称的节点集合　　 注意拼写:Elements</p> <p>document.getElementsByTagName(tagname); 　　//返回带有指定标签名的对象集合　  注意拼写：Elements</p> <p>document.getElementsByClassName(classname);  //返回带有指定class名称的对象集合 注意拼写：Elements</p> <h3 id="_2-创建节点-属性"><a href="#_2-创建节点-属性" class="header-anchor">#</a> 2.创建节点/属性</h3> <p>document.createElement(eName);　　//创建一个节点</p> <p>document.createAttribute(attrName); //对某个节点创建属性</p> <p>document.createTextNode(text);　　　//创建文本节点</p> <h3 id="_3-添加节点"><a href="#_3-添加节点" class="header-anchor">#</a> 3.添加节点</h3> <p>document.insertBefore(newNode,referenceNode);　 //在某个节点前插入节点</p> <p>parentNode.appendChild(newNode);　　　　　　　　//给某个节点添加子节点</p> <h3 id="_4-复制节点"><a href="#_4-复制节点" class="header-anchor">#</a> 4.复制节点</h3> <p>cloneNode(true | false);　　//复制某个节点  参数：是否复制原节点的所有属性</p> <h3 id="_5-删除节点"><a href="#_5-删除节点" class="header-anchor">#</a> 5.删除节点</h3> <p>parentNode.removeChild(node);　　//删除某个节点的子节点 node是要删除的节点</p> <h3 id="_7-属性操作"><a href="#_7-属性操作" class="header-anchor">#</a> 7.属性操作</h3> <p>getAttribute(name)　　　　//通过属性名称获取某个节点属性的值</p> <p>setAttribute(name,value);  //修改某个节点属性的值</p> <p>removeAttribute(name);　 //删除某个属性</p> <h3 id="_8-查找节点"><a href="#_8-查找节点" class="header-anchor">#</a> 8.查找节点</h3> <p>parentObj.firstChild;　　//如果节点为已知节点的第一个子节点就可以使用这个方法。此方法可以递归进行使用 parentObj.firstChild.firstChild.....</p> <p>parentObj.lastChild;　　//获得一个节点的最后一个节点，与firstChild一样也可以进行递归使用 parentObj.lastChild.lastChild.....</p> <p>parentObj.childNodes;   //获得节点的所有子节点，然后通过循环和索引找到目标节点</p> <h3 id="_9-获取相邻的节点"><a href="#_9-获取相邻的节点" class="header-anchor">#</a> 9.获取相邻的节点</h3> <p>curtNode.previousSibling;  //获取已知节点的相邻的上一个节点</p> <p>curtNode.nextSlbling;　　  // 获取已知节点的下一个节点</p> <h3 id="_10-获取父节点"><a href="#_10-获取父节点" class="header-anchor">#</a> 10.获取父节点</h3> <p>childNode.parentNode;　　//得到已知节点的父节点</p> <h3 id="_11-替换节点"><a href="#_11-替换节点" class="header-anchor">#</a> 11.替换节点</h3> <p>replace(newNode,oldNode);</p> <h2 id="_16-array-sort-方法与实现机制"><a href="#_16-array-sort-方法与实现机制" class="header-anchor">#</a> 16. Array.sort()方法与实现机制</h2> <p>该排序方法每个浏览器中实现的都不太一样</p> <p>chrome 目前采用快排(QuickSort)和插入排序(InsertaionSort),而对于火狐，它采用归并排序(MergeSort)。而IE使用快排。</p> <h2 id="_17-ajax的请求过程"><a href="#_17-ajax的请求过程" class="header-anchor">#</a> 17. Ajax的请求过程</h2> <p>第一步：创建异步对象</p> <p>var xhr = new XMLHttpRequest();</p> <p>第二步：设置 请求行 open(请求方式，请求url):</p> <p>// get请求如果有参数就需要在url后面拼接参数，
// post如果有参数，就在请求体中传递 xhr.open(&quot;get&quot;,&quot;validate.php?username=&quot;+name)
xhr.open(&quot;post&quot;,&quot;validate.php&quot;);</p> <p>第三步：设置请求（GET方式忽略此步骤）头:setRequestHeader()</p> <p>// 1.get不需要设置
// 2.post需要设置请求头：Content-Type:application/x-www-form-urlencoded
xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);</p> <p>第四步：设置请求体 send()</p> <p>// 1.get的参数在url拼接了，所以不需要在这个函数中设置
// 2.post的参数在这个函数中设置(如果有参数)
xhr.send(null) xhr.send(&quot;username=&quot;+name);</p> <p>第五步：让异步对象接收服务器的响应数据</p> <p>// 一个成功的响应有两个条件：1.服务器成功响应了 2.异步对象的响应状态为4(数据解析完毕可以使用了)</p> <p>xhr.onreadystatechange = function(){
if(xhr.status == 200 &amp;&amp; xhr.readyState == 4){
console.log(xhr.responseText);
}</p> <h2 id="_18-js的垃圾回收机制"><a href="#_18-js的垃圾回收机制" class="header-anchor">#</a> 18. JS的垃圾回收机制</h2> <h3 id="什么是js垃圾回收-what"><a href="#什么是js垃圾回收-what" class="header-anchor">#</a> 什么是js垃圾回收？(what)</h3> <p>JavaScript中也具有自动垃圾回收机制（GC：Garbage Collection）;</p> <p>因为内存内容是极其有限的，所以垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放内存</p> <p>其中不再使用的变量一般只可能是局部变量，即在函数执行结束的时候，所使用的局部变量所占的内存会随之被回收，当然在闭包中内部函数会占用着外部函数的局部变量。</p> <h3 id="有哪些垃圾回收方式-how"><a href="#有哪些垃圾回收方式-how" class="header-anchor">#</a> 有哪些垃圾回收方式？(how)</h3> <p>到底哪个变量是没有用的？所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存。</p> <p>用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：标记清除和引用计数。引用计数不太常用，标记清除较为常用。</p> <h4 id="_1-标记清除"><a href="#_1-标记清除" class="header-anchor">#</a> 1.标记清除：</h4> <p>垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p> <p>到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。</p> <h4 id="_2-引用计数"><a href="#_2-引用计数" class="header-anchor">#</a> 2.引用计数：</h4> <p>引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。</p> <h3 id="什么时候进行垃圾回收-when"><a href="#什么时候进行垃圾回收-when" class="header-anchor">#</a> 什么时候进行垃圾回收？(when)</h3> <p>垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。IE6的垃圾回收是根据内存分配量运行的，当环境中存在256个变量、4096个对象、64k的字符串任意一种情况的时候就会触发垃圾回收器工作，看起来很科学，不用按一段时间就调用一次，有时候会没必要，这样按需调用不是很好吗？但是如果环境中就是有这么多变量等一直存在，现在脚本如此复杂，很正常，那么结果就是垃圾回收器一直在工作，这样浏览器就没法儿玩儿了。</p> <p>微软在IE7中做了调整，触发条件不再是固定的，而是动态修改的，初始值和IE6相同，如果垃圾回收器回收的内存分配量低于程序占用内存的15%，说明大部分内存不可被回收，设的垃圾回收触发条件过于敏感，这时候把临街条件翻倍，如果回收的内存高于85%，说明大部分内存早就该清理了，这时候把触发条件置回。这样就使垃圾回收工作职能了很多。</p> <h2 id="_19-js中的string、array和math方法"><a href="#_19-js中的string、array和math方法" class="header-anchor">#</a> 19. JS中的String、Array和Math方法</h2> <h3 id="string"><a href="#string" class="header-anchor">#</a> String</h3> <ul><li>charAt() 返回指定位置的字符。</li> <li>charCodeAt() 返回字符串中某个具体字符的 Unicode编码。</li> <li>concat() 方法用于连接两个或多个字符串</li> <li>substring(start,end)</li> <li>slice(start,end)</li> <li>substr(start,length)</li> <li>toLowerCase(）</li> <li>toUpperCase()</li></ul> <p>字符串位置方法：</p> <ul><li><p>indexOf(searchValue, fromindex)
返回某个指定的字符串值在字符串中首次出现的位置。</p></li> <li><p>lastIndexOf(search, fromindex）
返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。</p></li> <li><p>trim()
字符串模式匹配</p></li> <li><p>match(searchvalue/Regexp)只接受一个参数，由字符串或RegExp对象指定的一个正则表达式 ，返回存放结果的数组</p></li> <li><p>search(searchvalue/Regexp)返回第一个与 regexp 相匹配的子串的起始位置。不执行全局匹配，它将忽略标志 g，总是从字符串的开始进行检索。</p></li> <li><p>replace(searchvalue/Regexp，replacement)replacement可以是字符串，可以是函数。</p></li> <li><p>split(separator,howmany) 方法用于把一个字符串分割成字符串数组。</p></li></ul> <h3 id="array"><a href="#array" class="header-anchor">#</a> Array</h3> <ul><li>concat() 用于连接两个或多个数组。
该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。</li> <li>push() 可接受任意数量参数，添加到数组末尾，返回修改数组的长度。</li> <li>pop() 从末尾移除最后一项，减少数组长度，返回移除的项</li> <li>unshift() 可接受任意数量参数，在数组前端添加任意个项，返回数组的长度</li> <li>shift() 移除数组中的第一个项，数组长度减一，返回移除的项</li> <li>reverse() 反转数组项的顺序</li> <li>sort() 按升序排列数组项</li> <li>slice() 一个或两个参数，返回起始位置和结束位置之间项不包括结束位置项</li> <li>splice()
删除：两个参数，要删除第一项的位置和要删除的项数
插入：（起始位置，0（要删除的项），要插入的项）
替换：(起始位置，要删除的项数，要插入的项)
该方法始终返回一个数组，该数组中包含从原始数组中删除的项。</li></ul> <p>位置方法·:</p> <ul><li>indexOf()</li> <li>lastIndexOf()</li></ul> <p>迭代方法：（要在每一项上运行的函数和（可选的）运行该函数的作用域对象）</p> <p>函数会接收三个参数：（数组项的值，数组项值的索引，数组对象本身）</p> <ul><li>every ：对数组中每一项运行函数，若该函数对每一项都返回true,则返回true。</li> <li>filter ：对数组中每一项运行函数，返回该函数会返回true的项组成的数组。</li> <li>foreach ：对数组中每一项运行函数，这个方法没有返回值。</li> <li>map ：对数组中每一项运行函数，返回函数每次调用的结果组成的数组。</li> <li>some：对数组中每一项运行函数，如果该函数有任一项返回true,则返回true</li></ul> <h3 id="math"><a href="#math" class="header-anchor">#</a> Math</h3> <p>ceil floor max min pow round random</p> <h2 id="_20-addeventlistener和onclick-的区别"><a href="#_20-addeventlistener和onclick-的区别" class="header-anchor">#</a> 20. addEventListener和onClick()的区别</h2> <p><strong>普通事件（onclick）</strong></p> <p>普通事件就是直接触发事件，同一时间只能指向唯一对象，所以会被覆盖掉。</p> <p><strong>事件绑定（addEventListener）</strong></p> <p>事件绑定就是对于一个可以绑定的事件对象，进行多次绑定事件都能运行。</p> <h3 id="二者区别"><a href="#二者区别" class="header-anchor">#</a> 二者区别</h3> <p>addEventListener对任何DOM都是有效的，而onclick仅限于HTML</p> <p>addEventListener可以控制listener的触发阶段,（捕获/冒泡）。对于多个相同的事件处理器，不会重复触发，不需要手动使用removeEventListener清除。</p> <p>总的来说：事件绑定是指把事件注册到具体的元素之上，普通事件指的是可以用来注册的事件</p> <h2 id="_21-new和object-create的区别"><a href="#_21-new和object-create的区别" class="header-anchor">#</a> 21. new和Object.create的区别</h2> <p><a href="https://juejin.cn/post/6844903917835436045" target="_blank" rel="noopener noreferrer">参考链接<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>字面量和new关键字创建的对象是Object的实例，原型指向Object.prototype，继承内置对象Object</p> <p>Object.create(arg, pro)创建的对象的原型取决于arg，arg为null，新对象是空对象，没有原型，不继承任何对象；arg为指定对象，新对象的原型指向指定对象，继承指定对象</p> <h2 id="_22-dom的location对象"><a href="#_22-dom的location对象" class="header-anchor">#</a> 22. DOM的location对象</h2> <p>location对象</p> <p>该对象包含有关当前url的信息，常用于修改和获取当前的网址</p> <p>常用属性：</p> <p>-hash：设置或返回从#开始的url（锚点）</p> <p>-host：设置或返回主机名和端口号</p> <p>-href：设置或获取当前的url地址</p> <p>-pathname：设置或获取当前url的路径部分</p> <p>常用方法：</p> <p>-reload()：重新加载当前页面</p> <h2 id="_23-浏览器从输入url到页面渲染的整个流程-涉及到计算机网络数据传输过程、浏览器解析渲染过程"><a href="#_23-浏览器从输入url到页面渲染的整个流程-涉及到计算机网络数据传输过程、浏览器解析渲染过程" class="header-anchor">#</a> 23. 浏览器从输入URL到页面渲染的整个流程（涉及到计算机网络数据传输过程、浏览器解析渲染过程）</h2> <p><strong>1.输入网址</strong></p> <p>输入要访问的网址，即URL</p> <p><strong>2.缓存解析</strong></p> <p>浏览器获取URL后，先去缓存中查找资源，从浏览器缓存-系统缓存-路由器缓存中查看；
如果有就从缓存中显示界面，不再发送请求；
如果没有，则发送http请求；</p> <p><strong>3.域名解析</strong></p> <p>发现缓存中没有资源，发送http请求；
在发送http请求之前，需要进行DNS解析(域名解析)；
DNS解析：域名到IP地址的转换过程，域名的解析工作由DNS服务器完成，解析后可以获取域名相应的IP地址；</p> <p><strong>4.tcp连接，三次握手</strong></p> <p>在域名解析后，浏览器向服务器发起了http请求，tcp连接；
因为tcp协议时面向连接的，所以在传输数据前必须建立连接，即三次握手；
tcp连接建立后，浏览器开始向服务器发送http请求，请求数据包。请求信息包含一个头部和一个请求体；</p> <p><strong>5.服务器收到请求</strong></p> <p>服务器收到浏览器发送的请求信息，返回一个响应头和一个响应体。</p> <p><strong>6.页面渲染</strong></p> <p>浏览器收到服务器发送的响应头和响应体，进行客户端渲染,生成Dom树，解析css样式,js交互。</p> <h2 id="_24-跨域、同源策略及跨域实现方式和原理"><a href="#_24-跨域、同源策略及跨域实现方式和原理" class="header-anchor">#</a> 24. 跨域、同源策略及跨域实现方式和原理</h2> <p><a href="https://juejin.cn/post/6844904006641254413" target="_blank" rel="noopener noreferrer">参考链接<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>首先，何为同源策略？ 同源策略是由Netspace提出来的一种安全策略。同源的源由一个URL的协议、主机、端口定义，如果这三者一致，那么就是同源。</p> <p>当不同源的时候，哪些操作被允许呢？</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;script&gt;加载Javascript
&lt;link&gt; 加载CSS
&lt;img&gt;加载图片
&lt;video&gt;&lt;audio&gt;加载多媒体
&lt;object&gt;&lt;embed&gt;&lt;applet&gt;加载插件
&lt;iframe&gt;加载任何东西
链接、跳转、表单提交

</code></pre></div><p>哪些不允许呢？</p> <ul><li>跨域文档之间使用Javascript脚本进行交互，API的访问有限制。比如iframe与父页面不同源，想要通过Javascript去操作父页面DOM是不被允许的</li> <li>不同源之间的XMLHttpRequest不被允许</li></ul> <h3 id="_1-修改源"><a href="#_1-修改源" class="header-anchor">#</a> 1.修改源</h3> <p>一个页面的源可以修改的，通过document.domain,比如一个页面a.b.com嵌入iframec.b.com，这时候只需要把两个页面的document.domain设置为b.com即可。</p> <h3 id="_2-使用代理"><a href="#_2-使用代理" class="header-anchor">#</a> 2.使用代理</h3> <p>跨域是针对前端来的，服务端是没有跨域这个东西的，所以后台设置一下，前端访问时访问一个同源页面，然后后台把请求的数据转到不同源的页面即可。</p> <h3 id="_3-jsonp"><a href="#_3-jsonp" class="header-anchor">#</a> 3.JSONP</h3> <p>因为script内嵌资源是允许的，所以可以把请求的接口放在script标签上，然后附带我们的回调函数</p> <p>存在安全问题
只能是GET请求
调用是异步的</p> <h3 id="_4-跨域资源共享cors"><a href="#_4-跨域资源共享cors" class="header-anchor">#</a> 4.跨域资源共享CORS</h3> <p>CORS需要浏览器和服务器同时支持，关键是服务器，只要服务器实现了CORS接口就可以跨域通信。</p> <p>Access-Control-Allow-Origin</p> <p>简单请求
head
get
post</p> <p>对于简单请求，浏览器在头信息里面加一个origin字段，说明本次请求来自哪个源(协议+主机+端口),服务器根据这个值，决定是否同意。如果origin不在指定的源里面，就会返回一个正常的HTTP回应，但是里面不包含Access-Control-Allow-Origin就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。</p> <p>非简单请求</p> <p>预请求 预回应</p> <p>非简单请求就是那种对服务器有特殊要求的请求，比如请求方法为PUT或DELETE</p> <h2 id="_25-浏览器的回流-reflow-和重绘-repaints"><a href="#_25-浏览器的回流-reflow-和重绘-repaints" class="header-anchor">#</a> 25. 浏览器的回流（Reflow）和重绘（Repaints）</h2> <p><a href="https://juejin.cn/post/6844903569087266823" target="_blank" rel="noopener noreferrer">参考链接<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p> <p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p> <h2 id="_26-javascript中的arguments"><a href="#_26-javascript中的arguments" class="header-anchor">#</a> 26. JavaScript中的arguments</h2> <p>如果函数以 () 的方式调用，那么 arguments 就是由所有参数组成的伪数组。</p> <p>如果函数以 call() 的方式调用，那么 arguments 指的就是第二个及之后的参数组成的伪数组。</p> <p>需要注意的是，在非严格模式下，arguments 可以被修改。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 非严格模式</span>
<span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span>
    arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y
<span class="token punctuation">}</span>
<span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment">// 200</span>
<span class="token function">sum</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment">// 200</span>

<span class="token comment">// 严格模式</span>
<span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token string">'use strict'</span>
    arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span>
    arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y
<span class="token punctuation">}</span>
<span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment">// 3</span>
<span class="token function">sum</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment">// 3</span>

</code></pre></div><h2 id="_27-eventloop事件循环"><a href="#_27-eventloop事件循环" class="header-anchor">#</a> 27. EventLoop事件循环</h2> <p>EventLoop中，每一次循环称为tick，每次循环的执行步骤如下：</p> <ul><li>js引擎线程中的执行栈会首先执行宏任务（一般是script），执行完所有的同步代码</li> <li>代码的执行过程中一定会有同步代码和异步代码，异步代码根据不同的任务类型，相应的回调函数会添加到宏任务队列和微任务队列中</li> <li>宏任务执行完后，检查微任务队列，清空微任务队列，执行完所有微任务</li> <li>微任务队列清空后，如果宿主为浏览器，可能会渲染页面，浏览器也会相应的优化，多个tick后合并成一次渲染页面</li> <li>开始下一轮tick，宏任务队列中拿出一个宏任务（注意是一个宏任务，setTimeout等回调）执行</li></ul> <p>注意页面渲染是在事件循环（EventLoop）之中的</p> <p>上面的步骤依次执行，实现一个闭环，也就是事件循环</p> <h2 id="_28-宏任务与微任务"><a href="#_28-宏任务与微任务" class="header-anchor">#</a> 28. 宏任务与微任务</h2> <p>任务队列有分宏任务队列和微任务队列，在代码执行过程中，不同的任务类型添加到不同的队列中，任务队列是先进先出原则</p> <h3 id="宏任务"><a href="#宏任务" class="header-anchor">#</a> 宏任务</h3> <p>宏任务是宿主环境本身提供的异步方法</p> <ul><li>script脚本</li> <li>setTimeout</li> <li>setInterval</li> <li>ajax</li> <li>DOM事件</li></ul> <h3 id="微任务"><a href="#微任务" class="header-anchor">#</a> 微任务</h3> <p>微任务是语言标准所提供的，如果在node中process.nextTick是微任务</p> <ul><li>Promise</li> <li>MutationObserver（Mutation Observer API 用来监视 DOM 变动）</li></ul> <h2 id="_29-bom属性对象方法-浏览器对象模型"><a href="#_29-bom属性对象方法-浏览器对象模型" class="header-anchor">#</a> 29. BOM属性对象方法  浏览器对象模型</h2> <p>BOM(Browser Object Model) 是指浏览器对象模型，是用于描述这种对象与对象之间层次关系的模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象（Screen、Location、History、Navigator）。</p> <p><img src="/BOM.jpg" alt="BOM"></p> <h3 id="window对象"><a href="#window对象" class="header-anchor">#</a> Window对象</h3> <p>Window对象，它表示浏览器窗口，在浏览器中最顶层的对象。在浏览器中，每个标签具有自己的 window 对象 。也就是说，同一个窗口的标签之间不会共享一个 window 对象。</p> <h3 id="location对象"><a href="#location对象" class="header-anchor">#</a> Location对象</h3> <p>Location 对象表示其链接到的对象的位置（URL）。所做的修改反映在与之相关的对象上。</p> <p>Document 和 Window 接口都有这样一个链接的Location，分别通过 Document.location和Window.location 访问。</p> <h3 id="history对象"><a href="#history对象" class="header-anchor">#</a> History对象</h3> <p>History 对象允许操作浏览器的曾经在标签页或者框架里访问的会话历史记录。</p> <h3 id="navigator对象"><a href="#navigator对象" class="header-anchor">#</a> Navigator对象</h3> <p>Navigator 接口表示用户代理的状态和标识。 它允许脚本查询它和注册自己进行一些活动。</p> <h3 id="document对象"><a href="#document对象" class="header-anchor">#</a> document对象</h3> <p>Document 对象提供了一些在浏览器服务中作为页面内容入口点而加载的一些页面，也就是 DOM 树。</p> <h2 id="_30-函数柯里化及其通用封装"><a href="#_30-函数柯里化及其通用封装" class="header-anchor">#</a> 30. 函数柯里化及其通用封装</h2> <p>函数柯里化是把接受多个参数的函数转变成接受一个单一参数(最初函数的第一个参数),并且返回接受余下的参数而且返回结果的新函数的技术</p> <p>柯里化其实本身是固定一个可以预期的参数，并返回一个特定的函数，处理批特定的需求。这增加了函数的适用性，但同时也降低了函数的适用范围。</p> <h2 id="_31-js的map-和reduce-方法"><a href="#_31-js的map-和reduce-方法" class="header-anchor">#</a> 31. JS的map()和reduce()方法</h2> <h3 id="array-map"><a href="#array-map" class="header-anchor">#</a> Array.map()</h3> <p>Array.map() 根据传递的转换函数，更新给定数组中的每个值，并返回一个相同长度的新数组。它接受一个回调函数作为参数，用以执行转换过程。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> newArray <span class="token operator">=</span>oldArray<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span>index<span class="token punctuation">,</span>array</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>一个帮助记住 map 的方法：Morph Array Piece-by-Piece（逐个改变数组） 你可以使用 map 代替 for-each 循环，来遍历并对每个值应用转换函数。这个方法适用于当你想更新数组的同时保留原始值。它不会潜在地删除任何值（filter 方法会），也不会计算出一个新的输出（就像 reduce 那样）。map 允许你逐个改变数组。一起来看一个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">,</span><span class="token number">78</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">val</span> <span class="token operator">=&gt;</span>val <span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token comment">// the result is: [10, 40, 60, 140, 320, 780]</span>
</code></pre></div><h3 id="array-filter"><a href="#array-filter" class="header-anchor">#</a> Array.filter()</h3> <p>当我们想要过滤数组的值到另一个数组，新数组中的每个值都通过一个特定检查，Array.filter() 这个快捷实用的方法就派上用场了。 类似搜索过滤器，filter 基于传递的参数来过滤出值。
举个例子，假定有个数字数组，想要过滤出大于 10 的值，可以这样写：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">,</span><span class="token number">78</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">val</span> <span class="token operator">=&gt;</span>val <span class="token operator">&gt;</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token comment">// the result is: [14, 32, 78]</span>
</code></pre></div><p>但是 filter 方法，只返回真值。因此如果所有值都执行指定的检查的话，结果的长度会小于等于原始数组。</p> <h2 id="_32-和-的区别"><a href="#_32-和-的区别" class="header-anchor">#</a> 32. “==”和“===”的区别</h2> <div class="language- extra-class"><pre><code> ===比较类型和值，==只比较值。
</code></pre></div><h2 id="_33-settimeout用作倒计时为何会产生误差"><a href="#_33-settimeout用作倒计时为何会产生误差" class="header-anchor">#</a> 33. setTimeout用作倒计时为何会产生误差？</h2> <p>当我们执行 JS 代码的时候其实就是往执行栈中放入函数，当遇到异步的代码时，会被挂起并在需要执行的时候加入到 Task（有多种 Task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行。</p> <p>上面讲了定时器是属于 宏任务(macrotask) 。如果当前 执行栈 所花费的时间大于 定时器 时间，那么定时器的回调在 宏任务(macrotask) 里，来不及去调用，所有这个时间会有误差。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/" class="prev router-link-active">
        首页
      </a></span> <span class="next"><a href="/blog/es6.html">
        es6
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.03c3e821.js" defer></script><script src="/assets/js/2.fef91045.js" defer></script><script src="/assets/js/10.38705d39.js" defer></script>
  </body>
</html>
